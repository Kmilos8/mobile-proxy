---
phase: 06-multi-tenant-isolation
plan: 02
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - server/internal/api/middleware/auth.go
  - server/internal/api/handler/router.go
  - server/internal/api/handler/device_handler.go
  - server/internal/api/handler/connection_handler.go
  - server/internal/api/handler/device_share_handler.go
  - server/internal/api/handler/customer_handler.go
  - server/internal/api/handler/pairing_handler.go
  - server/internal/service/device_share_service.go
  - server/internal/service/pairing_service.go
  - server/cmd/api/main.go
autonomous: true
requirements:
  - TENANT-01
  - TENANT-02
  - TENANT-03

must_haves:
  truths:
    - "Customer JWT requests to /api/devices return only owned + shared devices"
    - "Customer JWT requests to /api/devices/:id return 403 for devices they do not own or have shared access to"
    - "Admin JWT requests see all devices unfiltered as before"
    - "Admin-only routes (stats, customers, pairing-codes, relay-servers, rotation-links, settings) reject customer JWTs with 403"
    - "Suspended customer account returns 403 on all authenticated requests"
    - "Admin can suspend/activate customer accounts"
    - "Admin can assign a customer_id when creating a pairing code"
    - "Device claiming stamps customer_id from pairing code onto the new device"
    - "Device share CRUD endpoints exist for device owners"
    - "Connection endpoints are customer-scoped when called by customer role"
  artifacts:
    - path: "server/internal/api/middleware/auth.go"
      provides: "AdminOnlyMiddleware, customer suspension check"
      contains: "AdminOnlyMiddleware"
    - path: "server/internal/api/handler/device_share_handler.go"
      provides: "Share management endpoints"
      contains: "DeviceShareHandler"
    - path: "server/internal/service/device_share_service.go"
      provides: "Permission checking logic"
      contains: "DeviceShareService"
    - path: "server/internal/api/handler/router.go"
      provides: "Route groups with role-based middleware"
      contains: "AdminOnlyMiddleware"
  key_links:
    - from: "server/internal/api/middleware/auth.go"
      to: "server/internal/api/handler/router.go"
      via: "AdminOnlyMiddleware applied to admin route group"
      pattern: "AdminOnlyMiddleware"
    - from: "server/internal/api/handler/device_handler.go"
      to: "server/internal/repository/device_repo.go"
      via: "Role branching calls ListByCustomer vs List"
      pattern: "ListByCustomer"
    - from: "server/internal/api/handler/router.go"
      to: "server/internal/api/handler/device_share_handler.go"
      via: "Share endpoints registered in router"
      pattern: "device-shares"
---

<objective>
Wire multi-tenant middleware, role-branching in handlers, and device sharing endpoints into the backend API.

Purpose: This is the enforcement layer. Without middleware blocking customer access to admin routes and handlers filtering data by customer_id, the data layer from Plan 01 would be unused. This plan makes every API endpoint tenant-aware.

Output: AdminOnlyMiddleware protecting admin routes, role-branching in device/connection handlers, DeviceShareService with permission checks, DeviceShareHandler with CRUD endpoints, customer suspension enforcement, and pairing code customer assignment.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/06-multi-tenant-isolation/06-CONTEXT.md
@.planning/phases/06-multi-tenant-isolation/06-RESEARCH.md
@.planning/phases/06-multi-tenant-isolation/06-01-SUMMARY.md

@server/internal/api/middleware/auth.go
@server/internal/api/handler/router.go
@server/internal/api/handler/device_handler.go
@server/internal/api/handler/connection_handler.go
@server/internal/api/handler/customer_handler.go
@server/internal/api/handler/pairing_handler.go
@server/internal/service/pairing_service.go
@server/cmd/api/main.go

<interfaces>
<!-- Key types and contracts from Plan 01 (must exist before this plan runs). -->

From server/internal/domain/models.go (updated by 06-01):
```go
type Device struct {
    // ... all existing fields ...
    CustomerID *uuid.UUID `json:"customer_id" db:"customer_id"`
}

type DeviceShare struct {
    ID                uuid.UUID  `json:"id" db:"id"`
    DeviceID          uuid.UUID  `json:"device_id" db:"device_id"`
    OwnerID           uuid.UUID  `json:"owner_id" db:"owner_id"`
    SharedWith        uuid.UUID  `json:"shared_with" db:"shared_with"`
    CanRename         bool       `json:"can_rename" db:"can_rename"`
    CanManagePorts    bool       `json:"can_manage_ports" db:"can_manage_ports"`
    CanDownloadConfigs bool      `json:"can_download_configs" db:"can_download_configs"`
    CanRotateIP       bool       `json:"can_rotate_ip" db:"can_rotate_ip"`
    CreatedAt         time.Time  `json:"created_at" db:"created_at"`
    UpdatedAt         time.Time  `json:"updated_at" db:"updated_at"`
}

type PairingCode struct {
    // ... all existing fields ...
    CustomerID *uuid.UUID `json:"customer_id" db:"customer_id"`
}
```

From server/internal/repository/ (created/updated by 06-01):
```go
// DeviceRepository
func (r *DeviceRepository) ListByCustomer(ctx, customerID uuid.UUID) ([]domain.Device, error)
func (r *DeviceRepository) GetByIDForCustomer(ctx, deviceID, customerID uuid.UUID) (*domain.Device, error)

// ConnectionRepository
func (r *ConnectionRepository) ListByCustomer(ctx, customerID uuid.UUID) ([]domain.ProxyConnection, error)
func (r *ConnectionRepository) GetByIDForCustomer(ctx, connID, customerID uuid.UUID) (*domain.ProxyConnection, error)
func (r *ConnectionRepository) ListByDeviceForCustomer(ctx, deviceID, customerID uuid.UUID) ([]domain.ProxyConnection, error)

// DeviceShareRepository
func NewDeviceShareRepository(db *DB) *DeviceShareRepository
func (r *DeviceShareRepository) Create(ctx, share *domain.DeviceShare) error
func (r *DeviceShareRepository) GetByID(ctx, id uuid.UUID) (*domain.DeviceShare, error)
func (r *DeviceShareRepository) GetByDeviceAndCustomer(ctx, deviceID, customerID uuid.UUID) (*domain.DeviceShare, error)
func (r *DeviceShareRepository) ListByDevice(ctx, deviceID uuid.UUID) ([]domain.DeviceShare, error)
func (r *DeviceShareRepository) ListByCustomer(ctx, customerID uuid.UUID) ([]domain.DeviceShare, error)
func (r *DeviceShareRepository) Update(ctx, share *domain.DeviceShare) error
func (r *DeviceShareRepository) Delete(ctx, id uuid.UUID) error

// CustomerRepository (updated by 06-01)
func (r *CustomerRepository) UpdateActive(ctx, id uuid.UUID, active bool) error
func (r *CustomerRepository) GetStats(ctx, id uuid.UUID) (deviceCount, shareCount int, totalBandwidth int64, err error)
```

From server/internal/api/middleware/auth.go:
```go
func AuthMiddleware(authService *service.AuthService) gin.HandlerFunc
// Sets c.Set("user_id", claims.UserID), c.Set("user_email", claims.Email), c.Set("user_role", claims.Role)
```

From server/internal/service/auth_service.go:
```go
type JWTClaims struct {
    UserID uuid.UUID `json:"user_id"`
    Email  string    `json:"email"`
    Role   string    `json:"role"`    // "admin", "operator", or "customer"
    jwt.RegisteredClaims
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add middleware, DeviceShareService, and update handlers for role-branching</name>
  <files>
    server/internal/api/middleware/auth.go
    server/internal/service/device_share_service.go
    server/internal/api/handler/device_handler.go
    server/internal/api/handler/connection_handler.go
    server/internal/api/handler/customer_handler.go
  </files>
  <action>
**server/internal/api/middleware/auth.go** -- Add two new middleware functions after the existing AuthMiddleware:

1. `AdminOnlyMiddleware() gin.HandlerFunc` -- Reads `user_role` from gin context. If role is NOT "admin" and NOT "operator", returns 403 `{"error": "forbidden"}` and aborts. Otherwise calls c.Next().

2. `CustomerSuspensionCheck(customerRepo *repository.CustomerRepository) gin.HandlerFunc` -- Reads `user_role` from context. If role == "customer", reads `user_id` from context as uuid.UUID, calls `customerRepo.GetByID(ctx, userID)`. If err or customer.Active == false, returns 403 `{"error": "account suspended"}` and aborts. If role is admin/operator, just calls c.Next(). Import repository package.

**server/internal/service/device_share_service.go** -- Create new file:

```go
type DeviceShareService struct {
    shareRepo  *repository.DeviceShareRepository
    deviceRepo *repository.DeviceRepository
}

func NewDeviceShareService(shareRepo *repository.DeviceShareRepository, deviceRepo *repository.DeviceRepository) *DeviceShareService
```

Methods:
1. `CanAccess(ctx, deviceID uuid.UUID, customerID uuid.UUID) (bool, error)` -- Check if customer owns the device OR has any share. First check device.CustomerID == customerID (owner). If not, check shareRepo.GetByDeviceAndCustomer for a share record.
2. `CanDo(ctx, deviceID uuid.UUID, customerID uuid.UUID, perm string) (bool, error)` -- Owner can do everything. For shared users, look up the share and check the relevant permission boolean. Perm values: "rename", "manage_ports", "download_configs", "rotate_ip".
3. `CreateShare(ctx, share *domain.DeviceShare) error` -- Validates that share.OwnerID actually owns the device (device.CustomerID == share.OwnerID). If not, return error "not device owner". Also validates shared_with != owner_id. Then calls shareRepo.Create.
4. `UpdateShare(ctx, share *domain.DeviceShare) error` -- Validates caller is device owner. Calls shareRepo.Update.
5. `DeleteShare(ctx, shareID uuid.UUID, callerID uuid.UUID) error` -- Gets share by ID, validates share.OwnerID == callerID. Calls shareRepo.Delete.
6. `ListSharesForDevice(ctx, deviceID uuid.UUID) ([]domain.DeviceShare, error)` -- Delegates to shareRepo.ListByDevice.

**server/internal/api/handler/device_handler.go** -- Modify existing handlers:

1. Add `shareService *service.DeviceShareService` field to DeviceHandler struct. Update NewDeviceHandler to accept it as parameter (add after wsHub).

2. `List` handler: Read `user_role` from gin context. If "customer", read `user_id` as uuid.UUID (this IS the customer_id for customer tokens), call `deviceService.ListByCustomer(ctx, customerID)`. Otherwise call existing `deviceService.List(ctx)`. Note: DeviceService.ListByCustomer needs to be a thin wrapper calling deviceRepo.ListByCustomer -- add it.

3. `GetByID` handler: If role == "customer", call `deviceService.GetByIDForCustomer(ctx, id, customerID)`. If err (not found/not authorized), return 403 `{"error": "forbidden"}`. Otherwise use existing logic. Note: DeviceService.GetByIDForCustomer needs to be a thin wrapper -- add it.

4. `Update` handler: If role == "customer", check `shareService.CanDo(ctx, id, customerID, "rename")`. If not allowed, return 403.

5. `SendCommand` handler: If role == "customer", the command type determines the permission check. For "rotate_ip" command, check `shareService.CanDo(ctx, deviceID, customerID, "rotate_ip")`. For other commands, deny customers entirely (return 403) -- only admin can reboot, find phone, etc.

6. `GetIPHistory`, `GetBandwidth`, `GetBandwidthHourly`, `GetUptime` handlers: If role == "customer", check `shareService.CanAccess(ctx, deviceID, customerID)`. If not allowed, return 403. (Baseline: shared users can always VIEW.)

7. `GetCommands` handler: If role == "customer", check `shareService.CanAccess(ctx, deviceID, customerID)`. If not allowed, return 403.

Also add `ListByCustomer(ctx, customerID uuid.UUID) ([]domain.Device, error)` and `GetByIDForCustomer(ctx, deviceID, customerID uuid.UUID) (*domain.Device, error)` methods to DeviceService (server/internal/service/device_service.go) as thin wrappers delegating to deviceRepo.

**server/internal/api/handler/connection_handler.go** -- Modify:

1. Add `shareService *service.DeviceShareService` field. Add a `SetShareService` method matching the existing `SetConnectionService` pattern on DeviceHandler.

2. `List` handler: If role == "customer" and device_id query param is present, call `connService.ListByDeviceForCustomer(ctx, deviceID, customerID)`. If role == "customer" and no device_id, call `connService.ListByCustomer(ctx, customerID)`. Otherwise existing logic. Add corresponding thin wrapper methods to ConnectionService.

3. `GetByID` handler: If role == "customer", call `connService.GetByIDForCustomer(ctx, id, customerID)`. If err, return 403.

4. `Create` handler: If role == "customer", verify `shareService.CanDo(ctx, req.DeviceID, customerID, "manage_ports")`. If not, 403. Also set `req.CustomerID = &customerID` to stamp ownership.

5. `Delete` handler: If role == "customer", verify `shareService.CanDo(ctx, conn.DeviceID, customerID, "manage_ports")`. If not, 403. Need to fetch connection first to get DeviceID.

6. `RegeneratePassword` handler: If role == "customer", first fetch connection to get DeviceID, then check `shareService.CanDo(ctx, deviceID, customerID, "manage_ports")`.

7. `ResetBandwidth` handler: If role == "customer", return 403 (admin-only action).

**server/internal/api/handler/customer_handler.go** -- Enhance for admin customer management:

1. Add `customerRepo` reference is already there. Add methods:
   - `Suspend(c *gin.Context)` -- Parse customer ID from URL param, call `customerRepo.UpdateActive(ctx, id, false)`. Return 200.
   - `Activate(c *gin.Context)` -- Parse customer ID from URL param, call `customerRepo.UpdateActive(ctx, id, true)`. Return 200.
   - `GetDetail(c *gin.Context)` -- Gets customer by ID plus calls `customerRepo.GetStats(ctx, id)` to include device_count, share_count, total_bandwidth in response. Returns enriched customer JSON.

Note: add thin wrapper methods to ConnectionService for ListByCustomer, GetByIDForCustomer, ListByDeviceForCustomer delegating to connRepo. The service layer is thin in this codebase -- just call through.
  </action>
  <verify>
    <automated>cd server && go build ./...</automated>
  </verify>
  <done>AdminOnlyMiddleware and CustomerSuspensionCheck middleware exist. DeviceShareService has CanAccess, CanDo, CreateShare, UpdateShare, DeleteShare. Device and connection handlers branch on role, using customer-scoped repo methods for customer tokens. CustomerHandler has Suspend, Activate, GetDetail. Code compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create DeviceShareHandler, wire routes, and update pairing flow</name>
  <files>
    server/internal/api/handler/device_share_handler.go
    server/internal/api/handler/router.go
    server/internal/api/handler/pairing_handler.go
    server/internal/service/pairing_service.go
    server/cmd/api/main.go
  </files>
  <action>
**server/internal/api/handler/device_share_handler.go** -- Create new file:

```go
type DeviceShareHandler struct {
    shareService *service.DeviceShareService
}

func NewDeviceShareHandler(shareService *service.DeviceShareService) *DeviceShareHandler
```

Endpoints (all require authenticated customer who owns the device):

1. `CreateShare(c *gin.Context)` -- Parse JSON body: `{ "device_id": uuid, "shared_with": uuid, "can_rename": bool, "can_manage_ports": bool, "can_download_configs": bool, "can_rotate_ip": bool }`. Read `user_id` from context as owner. Build DeviceShare, call shareService.CreateShare. Return 201.

2. `ListShares(c *gin.Context)` -- Query param `device_id` required. Read role. If customer, verify CanAccess on device. Call shareService.ListSharesForDevice. Return 200.

3. `UpdateShare(c *gin.Context)` -- Parse share ID from URL, parse body with permission booleans. Get existing share, verify caller is owner. Update permissions. Return 200.

4. `DeleteShare(c *gin.Context)` -- Parse share ID from URL. Read `user_id` from context. Call shareService.DeleteShare(ctx, shareID, callerID). Return 200.

**server/internal/api/handler/router.go** -- Major restructure of route groups:

The current `dashboard` group uses a single AuthMiddleware with no role checks. Restructure:

1. Keep the existing `dashboard` group with AuthMiddleware. Add `CustomerSuspensionCheck(customerRepo)` middleware to this group (runs after AuthMiddleware).

2. Create an `adminOnly` sub-group within dashboard for admin-exclusive routes. Apply `AdminOnlyMiddleware()`:
```go
adminOnly := dashboard.Group("")
adminOnly.Use(middleware.AdminOnlyMiddleware())
{
    adminOnly.GET("/stats/overview", statsHandler.Overview)
    adminOnly.GET("/customers", customerHandler.List)
    adminOnly.POST("/customers", customerHandler.Create)
    adminOnly.GET("/customers/:id", customerHandler.GetDetail)
    adminOnly.PUT("/customers/:id", customerHandler.Update)
    adminOnly.POST("/customers/:id/suspend", customerHandler.Suspend)
    adminOnly.POST("/customers/:id/activate", customerHandler.Activate)
    adminOnly.GET("/rotation-links", rotationLinkHandler.List)
    adminOnly.POST("/rotation-links", rotationLinkHandler.Create)
    adminOnly.DELETE("/rotation-links/:id", rotationLinkHandler.Delete)
    adminOnly.GET("/pairing-codes", pairingHandler.ListCodes)
    adminOnly.POST("/pairing-codes", pairingHandler.CreateCode)
    adminOnly.DELETE("/pairing-codes/:id", pairingHandler.DeleteCode)
    adminOnly.GET("/relay-servers", relayServerHandler.List)
    adminOnly.GET("/relay-servers/active", relayServerHandler.ListActive)
    adminOnly.POST("/relay-servers", relayServerHandler.Create)
    // Settings webhook routes (move from dashboard group)
    adminOnly.GET("/settings/webhook", ...)
    adminOnly.PUT("/settings/webhook", ...)
    adminOnly.POST("/settings/webhook/test", ...)
}
```

3. Keep device/connection routes in the main `dashboard` group (accessible to both admin and customer, but handlers branch on role internally):
```go
dashboard.GET("/devices", deviceHandler.List)
dashboard.GET("/devices/:id", deviceHandler.GetByID)
dashboard.PATCH("/devices/:id", deviceHandler.Update)
dashboard.POST("/devices/:id/commands", deviceHandler.SendCommand)
dashboard.GET("/devices/:id/ip-history", deviceHandler.GetIPHistory)
dashboard.GET("/devices/:id/bandwidth", deviceHandler.GetBandwidth)
dashboard.GET("/devices/:id/bandwidth/hourly", deviceHandler.GetBandwidthHourly)
dashboard.GET("/devices/:id/uptime", deviceHandler.GetUptime)
dashboard.GET("/devices/:id/commands", deviceHandler.GetCommands)

dashboard.GET("/connections", connHandler.List)
dashboard.POST("/connections", connHandler.Create)
dashboard.GET("/connections/:id", connHandler.GetByID)
dashboard.PATCH("/connections/:id", connHandler.SetActive)
dashboard.DELETE("/connections/:id", connHandler.Delete)
dashboard.POST("/connections/:id/regenerate-password", connHandler.RegeneratePassword)
dashboard.POST("/connections/:id/reset-bandwidth", connHandler.ResetBandwidth)

// Device shares (accessible to authenticated users -- handler checks ownership)
dashboard.GET("/device-shares", deviceShareHandler.ListShares)
dashboard.POST("/device-shares", deviceShareHandler.CreateShare)
dashboard.PUT("/device-shares/:id", deviceShareHandler.UpdateShare)
dashboard.DELETE("/device-shares/:id", deviceShareHandler.DeleteShare)
```

4. Keep the .ovpn download route in dashboard group (customer needs download access with permission check):
```go
dashboard.GET("/connections/:id/ovpn", openvpnHandler.DownloadOVPN)
```
The openvpnHandler.DownloadOVPN also needs a role-branch: if customer, verify CanDo(ctx, deviceID, customerID, "download_configs"). Get the connection first to find deviceID.

5. Update SetupRouter signature to accept the new dependencies: `deviceShareHandler *DeviceShareHandler`, `customerRepo *repository.CustomerRepository` (for suspension check middleware). The customerRepo is already passed as userRepo but for customers we need customerRepo.

**server/internal/api/handler/pairing_handler.go** -- Update CreateCode:

1. Update CreateCode to read optional `customer_id` from the request body. The domain.CreatePairingCodeRequest already has CustomerID from Plan 01. Pass it through to pairingService.CreateCode.

**server/internal/service/pairing_service.go** -- Update:

1. Update `CreateCode` to accept `customerID *uuid.UUID` parameter. Store it in the PairingCode record.
2. Update `ClaimCode` (or wherever device registration happens via pairing code): when a device is created from a claimed pairing code, stamp `devices.customer_id` from `pairingCode.CustomerID`. This means the device Create or Update call should set CustomerID.

**server/cmd/api/main.go** -- Update wiring:

1. Create `deviceShareRepo := repository.NewDeviceShareRepository(db)`
2. Create `deviceShareService := service.NewDeviceShareService(deviceShareRepo, deviceRepo)`
3. Create `deviceShareHandler := handler.NewDeviceShareHandler(deviceShareService)`
4. Pass deviceShareService to DeviceHandler (update NewDeviceHandler call)
5. Pass deviceShareService to ConnectionHandler (via SetShareService or constructor update)
6. Update SetupRouter call to pass deviceShareHandler and customerRepo
7. Pass customerRepo to SetupRouter (for suspension middleware)
  </action>
  <verify>
    <automated>cd server && go build ./...</automated>
  </verify>
  <done>Routes restructured: admin-only routes protected by AdminOnlyMiddleware, device/connection routes accessible to both roles with handler branching, device-shares CRUD endpoints wired, pairing code flow stamps customer_id on device creation, CustomerSuspensionCheck middleware active, main.go wires all new dependencies. Code compiles.</done>
</task>

</tasks>

<verification>
- `cd server && go build ./...` compiles without errors
- AdminOnlyMiddleware returns 403 for customer role
- Customer-scoped handlers call ListByCustomer/GetByIDForCustomer
- DeviceShareHandler endpoints are registered in router
- Pairing flow stamps customer_id on new devices
- Suspended customer check runs on every authenticated request
</verification>

<success_criteria>
1. All admin-only routes (stats, customers, pairing-codes, relay-servers, rotation-links, settings) reject customer JWTs with 403
2. GET /api/devices with customer JWT returns only owned + shared devices
3. GET /api/devices/:id with customer JWT returns 403 for unowned devices
4. GET /api/connections with customer JWT returns only customer's connections
5. Device share CRUD endpoints work (create, list, update, delete)
6. Suspended customer gets 403 on all authenticated requests
7. Admin creating pairing code with customer_id stamps ownership on device claim
8. `go build ./...` passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-multi-tenant-isolation/06-02-SUMMARY.md`
</output>
