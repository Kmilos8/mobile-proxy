---
phase: 05-auth-foundation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - server/internal/service/customer_auth_service.go
  - server/internal/service/email_service.go
  - server/internal/api/handler/customer_auth_handler.go
  - server/internal/api/handler/router.go
  - server/cmd/api/main.go
autonomous: true
requirements: [AUTH-01, AUTH-02, AUTH-03, AUTH-04, AUTH-05]

must_haves:
  truths:
    - "POST /api/auth/customer/signup creates customer with hashed password and sends verification email"
    - "POST /api/auth/customer/login returns JWT only if email is verified"
    - "GET /api/auth/customer/verify-email?token=X returns token validity status"
    - "POST /api/auth/customer/verify-email consumes token and marks email verified"
    - "POST /api/auth/customer/forgot-password sends reset email"
    - "POST /api/auth/customer/reset-password changes password using valid token"
    - "GET /api/auth/customer/google redirects to Google OAuth consent screen"
    - "GET /api/auth/customer/google/callback handles OAuth code exchange and returns JWT"
    - "All three public endpoints (signup, login, forgot-password) verify Turnstile token server-side"
  artifacts:
    - path: "server/internal/service/customer_auth_service.go"
      provides: "Business logic for all customer auth flows"
      exports: ["CustomerAuthService", "Signup", "Login", "VerifyEmail", "ForgotPassword", "ResetPassword", "GoogleLogin", "GoogleCallback"]
    - path: "server/internal/service/email_service.go"
      provides: "Resend email client wrapper"
      exports: ["EmailService", "SendVerification", "SendPasswordReset"]
    - path: "server/internal/api/handler/customer_auth_handler.go"
      provides: "HTTP handlers for all customer auth endpoints"
      exports: ["CustomerAuthHandler"]
    - path: "server/internal/api/handler/router.go"
      provides: "Route registration for customer auth endpoints"
      contains: "/api/auth/customer"
    - path: "server/cmd/api/main.go"
      provides: "Service wiring and dependency injection"
      contains: "customerAuthHandler"
  key_links:
    - from: "server/internal/api/handler/customer_auth_handler.go"
      to: "server/internal/service/customer_auth_service.go"
      via: "handler calls service methods"
      pattern: "customerAuthService\\."
    - from: "server/internal/service/customer_auth_service.go"
      to: "server/internal/repository/customer_repo.go"
      via: "service queries customer data"
      pattern: "customerRepo\\."
    - from: "server/internal/service/customer_auth_service.go"
      to: "server/internal/service/email_service.go"
      via: "service sends verification and reset emails"
      pattern: "emailService\\."
    - from: "server/internal/api/handler/router.go"
      to: "server/internal/api/handler/customer_auth_handler.go"
      via: "route registration"
      pattern: "customerAuthHandler\\."
    - from: "server/cmd/api/main.go"
      to: "server/internal/service/customer_auth_service.go"
      via: "dependency injection in main"
      pattern: "NewCustomerAuthService"
---

<objective>
Build the complete backend auth service layer, HTTP handlers, and route wiring for all customer authentication flows.

Purpose: This plan implements the core business logic for customer signup, login, email verification, password reset, Google OAuth, and Turnstile verification. It connects the data layer (Plan 01) to HTTP endpoints that the frontend (Plan 03) will call.

Output: CustomerAuthService, EmailService, CustomerAuthHandler, updated router and main.go wiring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-auth-foundation/05-CONTEXT.md
@.planning/phases/05-auth-foundation/05-RESEARCH.md
@.planning/phases/05-auth-foundation/05-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 outputs — the executor needs these contracts -->

From server/internal/domain/models.go (after Plan 01):
```go
type Customer struct {
    ID            uuid.UUID  `json:"id" db:"id"`
    Name          string     `json:"name" db:"name"`
    Email         string     `json:"email" db:"email"`
    Active        bool       `json:"active" db:"active"`
    PasswordHash  *string    `json:"-" db:"password_hash"`
    EmailVerified bool       `json:"email_verified" db:"email_verified"`
    GoogleID      *string    `json:"-" db:"google_id"`
    GoogleEmail   *string    `json:"google_email,omitempty" db:"google_email"`
    CreatedAt     time.Time  `json:"created_at" db:"created_at"`
    UpdatedAt     time.Time  `json:"updated_at" db:"updated_at"`
}

type CustomerAuthToken struct {
    ID         uuid.UUID  `json:"id" db:"id"`
    CustomerID uuid.UUID  `json:"customer_id" db:"customer_id"`
    TokenHash  string     `json:"-" db:"token_hash"`
    Type       string     `json:"type" db:"type"`
    ExpiresAt  time.Time  `json:"expires_at" db:"expires_at"`
    UsedAt     *time.Time `json:"used_at,omitempty" db:"used_at"`
    CreatedAt  time.Time  `json:"created_at" db:"created_at"`
}

type CustomerSignupRequest struct { Email, Password, TurnstileToken string }
type CustomerLoginRequest struct { Email, Password, TurnstileToken string }
type CustomerLoginResponse struct { Token string; Customer Customer }
type ForgotPasswordRequest struct { Email, TurnstileToken string }
type ResetPasswordRequest struct { Token, Password, ConfirmPassword string }
type VerifyEmailRequest struct { Token string }
type ResendVerificationRequest struct { Email string }
```

From server/internal/domain/config.go (after Plan 01):
```go
type GoogleOAuthConfig struct { ClientID, ClientSecret, RedirectURL string }
type ResendConfig struct { APIKey, FromEmail, BaseURL string }
type TurnstileConfig struct { SiteKey, SecretKey string }
```

From server/internal/repository/customer_repo.go (after Plan 01):
```go
func (r *CustomerRepository) GetByEmail(ctx, email) (*domain.Customer, error)
func (r *CustomerRepository) GetByGoogleID(ctx, googleID) (*domain.Customer, error)
func (r *CustomerRepository) CreateWithAuth(ctx, c *domain.Customer) error
func (r *CustomerRepository) UpdateEmailVerified(ctx, id, verified) error
func (r *CustomerRepository) UpdatePasswordHash(ctx, id, hash) error
func (r *CustomerRepository) LinkGoogleAccount(ctx, id, googleID, googleEmail) error
```

From server/internal/repository/customer_token_repo.go (after Plan 01):
```go
func (r *CustomerTokenRepository) Create(ctx, token *domain.CustomerAuthToken) error
func (r *CustomerTokenRepository) GetByHash(ctx, tokenHash) (*domain.CustomerAuthToken, error)
func (r *CustomerTokenRepository) MarkUsed(ctx, id) error
func (r *CustomerTokenRepository) DeleteByCustomerAndType(ctx, customerID, tokenType) error
```

From server/internal/service/auth_service.go (existing):
```go
type JWTClaims struct {
    UserID uuid.UUID `json:"user_id"`
    Email  string    `json:"email"`
    Role   string    `json:"role"`
    jwt.RegisteredClaims
}
func (s *AuthService) ValidateToken(tokenString string) (*JWTClaims, error)
```

From server/internal/api/handler/router.go (existing):
```go
func SetupRouter(authService, deviceService, connService, bwService, customerHandler, vpnHandler, statsHandler, rotationLinkHandler, pairingHandler, relayServerHandler, wsHub, openvpnHandler, syncHandler, userRepo) *gin.Engine
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Email service, Turnstile helper, and customer auth service</name>
  <files>
    server/internal/service/email_service.go
    server/internal/service/customer_auth_service.go
  </files>
  <action>
    **Install new Go dependencies first:**
    ```bash
    cd server && go get golang.org/x/oauth2 && go get github.com/resend/resend-go/v3
    ```

    **1. Create `server/internal/service/email_service.go`:**

    EmailService wraps the Resend Go SDK for transactional email delivery.

    ```go
    type EmailService struct {
        client  *resend.Client
        from    string
        baseURL string // dashboard URL for building links
    }
    func NewEmailService(cfg domain.ResendConfig) *EmailService
    ```

    Methods:
    - `SendVerification(to, rawToken string) error` — sends verification email with link `{baseURL}/verify-email?token={rawToken}`. Subject: "Verify your PocketProxy account". HTML body: simple styled message with a prominent "Verify Email" button/link. Include text: "This link expires in 24 hours." If Resend API key is empty, log the email contents instead of sending (for development without Resend configured).

    - `SendPasswordReset(to, rawToken string) error` — sends password reset email with link `{baseURL}/reset-password?token={rawToken}`. Subject: "Reset your PocketProxy password". HTML body: simple styled message with "Reset Password" button/link. Include text: "This link expires in 24 hours. If you didn't request this, ignore this email."

    Email HTML should be simple inline-styled (no external CSS) — a centered card with the PocketProxy brand color (#8b5cf6), white text, and a prominent action button.

    **2. Create `server/internal/service/customer_auth_service.go`:**

    ```go
    type CustomerAuthService struct {
        customerRepo *repository.CustomerRepository
        tokenRepo    *repository.CustomerTokenRepository
        emailService *EmailService
        jwtConfig    domain.JWTConfig
        googleConfig domain.GoogleOAuthConfig
        turnstileCfg domain.TurnstileConfig
    }
    func NewCustomerAuthService(
        customerRepo *repository.CustomerRepository,
        tokenRepo *repository.CustomerTokenRepository,
        emailService *EmailService,
        jwtConfig domain.JWTConfig,
        googleConfig domain.GoogleOAuthConfig,
        turnstileCfg domain.TurnstileConfig,
    ) *CustomerAuthService
    ```

    **Helper functions (private, in same file):**

    - `generateToken() (raw string, hashed string, err error)` — uses `crypto/rand` to generate 32 random bytes, returns hex-encoded raw token and SHA-256 hash of the raw token. NEVER use math/rand.

    - `verifyTurnstile(token, remoteIP string) (bool, error)` — POST to `https://challenges.cloudflare.com/turnstile/v0/siteverify` with secret key, response token, and remoteip. Parse JSON response for `success` field. If secret key is empty, return true (for development without Turnstile configured).

    - `generateCustomerJWT(customer *domain.Customer) (string, error)` — same pattern as existing `AuthService.generateToken` but with `Role: "customer"` and `UserID: customer.ID`. Uses the same `JWTClaims` struct from `service` package. Expire in 24 hours.

    **Public methods:**

    - `Signup(ctx, req *domain.CustomerSignupRequest, remoteIP string) error`:
      1. Verify Turnstile token (reject if fails)
      2. Check if email already exists (GetByEmail) — return conflict error if so
      3. Hash password with bcrypt (DefaultCost)
      4. Create customer via CreateWithAuth (email_verified=false, Name=email prefix before @, Active=true)
      5. Generate verification token, delete any existing email_verify tokens for this customer, store hashed token with type="email_verify" and expires_at=NOW()+24h
      6. Send verification email with raw token
      7. Return nil (success)

    - `Login(ctx, req *domain.CustomerLoginRequest, remoteIP string) (*domain.CustomerLoginResponse, error)`:
      1. Verify Turnstile token
      2. Get customer by email — return "invalid credentials" if not found
      3. Check customer has password_hash (Google-only users cannot login with password) — return "invalid credentials" if nil
      4. Compare bcrypt hash — return "invalid credentials" if mismatch
      5. Check email_verified — if false, return a specific error indicating "email not verified" (handler will return 403 with message "Please verify your email first")
      6. Generate JWT and return CustomerLoginResponse

    - `VerifyEmailCheck(ctx, rawToken string) (bool, error)` — hash the raw token, call GetByHash, return whether token is valid (exists, not expired, not used). This is for the GET endpoint that shows the confirmation page.

    - `VerifyEmail(ctx, rawToken string) (*domain.CustomerLoginResponse, error)`:
      1. Hash raw token, look up by hash (GetByHash)
      2. If not found or expired → return error
      3. Mark token used (MarkUsed)
      4. Update customer email_verified=true (UpdateEmailVerified)
      5. Fetch updated customer (GetByID using token.CustomerID)
      6. Generate JWT and return CustomerLoginResponse (auto-login after verification)

    - `ResendVerification(ctx, email string) error`:
      1. Get customer by email — silently succeed if not found (prevent email enumeration)
      2. If already verified, return error "email already verified"
      3. Delete existing email_verify tokens for this customer
      4. Generate new token, store, send email
      5. Return nil

    - `ForgotPassword(ctx, req *domain.ForgotPasswordRequest, remoteIP string) error`:
      1. Verify Turnstile token
      2. Get customer by email — silently succeed if not found (prevent email enumeration)
      3. Delete existing password_reset tokens for this customer
      4. Generate token, store with type="password_reset" and expires_at=NOW()+24h
      5. Send password reset email with raw token
      6. Return nil

    - `ResetPassword(ctx, req *domain.ResetPasswordRequest) error`:
      1. Validate password == confirm_password — return error if mismatch
      2. Hash raw token, look up by hash (GetByHash)
      3. If not found or expired → return error
      4. Mark token used
      5. Hash new password with bcrypt
      6. Update customer password hash (UpdatePasswordHash)
      7. Return nil

    - `GoogleAuthURL() string`:
      1. Build oauth2.Config with google.Endpoint, scopes ["userinfo.email", "userinfo.profile"]
      2. Generate random state token (32 bytes, hex encoded)
      3. Return the AuthCodeURL with state. The state needs to be returned to the handler so it can be stored in a cookie.
      Actually, return (url string, state string) so the handler can set the state cookie.

    - `GoogleCallback(ctx, code, state string) (*domain.CustomerLoginResponse, string, error)`:
      1. Exchange code for OAuth2 token using googleConfig
      2. Use token to call `https://www.googleapis.com/oauth2/v2/userinfo`
      3. Parse userinfo response: id, email, verified_email, name
      4. Check GetByGoogleID — if found, generate JWT and return (existing Google user)
      5. Check GetByEmail — if found, link Google account (LinkGoogleAccount) and generate JWT (account linking)
      6. If neither found — create new customer via CreateWithAuth with google_id set, email_verified=true (Google users are auto-verified), password_hash=nil
      7. Generate JWT and return
      8. The second return value is a redirect URL (dashboard base URL + "/devices" for now, or a frontend callback page)

    **Important implementation notes:**
    - Use `golang.org/x/oauth2` and `golang.org/x/oauth2/google` for OAuth config
    - For state parameter CSRF protection: generate random state, handler stores it in a short-lived cookie, callback verifies cookie matches state query param
    - All error messages to the user should be generic (prevent email enumeration) except for the "email not verified" case which needs a specific message so the frontend can show the resend option
    - Lowercase all emails before storing/comparing (strings.ToLower)
  </action>
  <verify>
    Run `cd server && go build ./...` to confirm all service files compile. Verify that `customer_auth_service.go` imports `golang.org/x/oauth2`, `golang.org/x/oauth2/google`, `github.com/resend/resend-go/v3`, `crypto/rand`, `crypto/sha256`.
  </verify>
  <done>
    EmailService sends verification and password reset emails via Resend SDK (with dev fallback to logging). CustomerAuthService implements all auth flows: Signup, Login, VerifyEmail, ResendVerification, ForgotPassword, ResetPassword, GoogleAuthURL, GoogleCallback. Turnstile server-side verification works. All code compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Customer auth HTTP handler, route registration, and main.go wiring</name>
  <files>
    server/internal/api/handler/customer_auth_handler.go
    server/internal/api/handler/router.go
    server/cmd/api/main.go
  </files>
  <action>
    **1. Create `server/internal/api/handler/customer_auth_handler.go`:**

    ```go
    type CustomerAuthHandler struct {
        customerAuthService *service.CustomerAuthService
    }
    func NewCustomerAuthHandler(s *service.CustomerAuthService) *CustomerAuthHandler
    ```

    Handlers (each is a gin.HandlerFunc):

    - `Signup(c *gin.Context)`:
      Bind CustomerSignupRequest JSON. Call customerAuthService.Signup with c.ClientIP(). Return 201 `{"message": "check your email to verify your account"}` on success. Return 409 on email conflict. Return 400 on validation/turnstile errors.

    - `Login(c *gin.Context)`:
      Bind CustomerLoginRequest JSON. Call customerAuthService.Login with c.ClientIP(). Return 200 with CustomerLoginResponse on success. Return 401 on invalid credentials. Return 403 with `{"error": "Please verify your email first", "code": "email_not_verified"}` if email not verified (the frontend uses the "code" field to show the resend option).

    - `VerifyEmailCheck(c *gin.Context)`:
      Read `token` from query param. Call customerAuthService.VerifyEmailCheck. Return 200 `{"valid": true}` or 200 `{"valid": false, "reason": "expired or invalid"}`.

    - `VerifyEmail(c *gin.Context)`:
      Bind VerifyEmailRequest JSON body. Call customerAuthService.VerifyEmail. Return 200 with CustomerLoginResponse (auto-login). Return 400 on invalid/expired token.

    - `ResendVerification(c *gin.Context)`:
      Bind ResendVerificationRequest JSON body. Call customerAuthService.ResendVerification. Always return 200 `{"message": "if that email is registered, a verification link has been sent"}` (prevent enumeration).

    - `ForgotPassword(c *gin.Context)`:
      Bind ForgotPasswordRequest JSON. Call customerAuthService.ForgotPassword with c.ClientIP(). Always return 200 `{"message": "if that email is registered, a password reset link has been sent"}` (prevent enumeration).

    - `ResetPassword(c *gin.Context)`:
      Bind ResetPasswordRequest JSON. Call customerAuthService.ResetPassword. Return 200 `{"message": "password updated successfully"}` on success. Return 400 on invalid/expired token or password mismatch.

    - `GoogleLogin(c *gin.Context)`:
      Call customerAuthService.GoogleAuthURL(). Set `oauth_state` cookie (HttpOnly, SameSite=Lax, Path=/, MaxAge=600 i.e. 10 minutes) with the returned state string. Redirect (307) to the returned URL.

    - `GoogleCallback(c *gin.Context)`:
      Read `code` and `state` from query params. Read `oauth_state` cookie. Verify state matches cookie value — return 400 if mismatch. Delete the cookie. Call customerAuthService.GoogleCallback with code and state. On success, redirect to `{baseURL}/login?token={jwt}&google=true` so the frontend can store the token and redirect. This avoids returning JSON on a redirect-based flow.

    **2. Update `server/internal/api/handler/router.go`:**

    Add `customerAuthHandler *CustomerAuthHandler` parameter to `SetupRouter` function signature.

    Add customer auth public routes BEFORE the dashboard middleware group (these are unauthenticated):
    ```go
    // Customer auth routes (public)
    customerAuth := r.Group("/api/auth/customer")
    {
        customerAuth.POST("/signup", customerAuthHandler.Signup)
        customerAuth.POST("/login", customerAuthHandler.Login)
        customerAuth.GET("/verify-email", customerAuthHandler.VerifyEmailCheck)
        customerAuth.POST("/verify-email", customerAuthHandler.VerifyEmail)
        customerAuth.POST("/resend-verification", customerAuthHandler.ResendVerification)
        customerAuth.POST("/forgot-password", customerAuthHandler.ForgotPassword)
        customerAuth.POST("/reset-password", customerAuthHandler.ResetPassword)
        customerAuth.GET("/google", customerAuthHandler.GoogleLogin)
        customerAuth.GET("/google/callback", customerAuthHandler.GoogleCallback)
    }
    ```

    **3. Update `server/cmd/api/main.go`:**

    Add environment variable loading in `loadConfig()` for the new config fields:
    ```go
    if v := os.Getenv("GOOGLE_CLIENT_ID"); v != "" { cfg.Google.ClientID = v }
    if v := os.Getenv("GOOGLE_CLIENT_SECRET"); v != "" { cfg.Google.ClientSecret = v }
    if v := os.Getenv("GOOGLE_REDIRECT_URL"); v != "" { cfg.Google.RedirectURL = v }
    if v := os.Getenv("RESEND_API_KEY"); v != "" { cfg.Resend.APIKey = v }
    if v := os.Getenv("RESEND_FROM_EMAIL"); v != "" { cfg.Resend.FromEmail = v }
    if v := os.Getenv("DASHBOARD_BASE_URL"); v != "" { cfg.Resend.BaseURL = v }
    if v := os.Getenv("TURNSTILE_SITE_KEY"); v != "" { cfg.Turnstile.SiteKey = v }
    if v := os.Getenv("TURNSTILE_SECRET_KEY"); v != "" { cfg.Turnstile.SecretKey = v }
    ```

    Add service and handler instantiation in main():
    ```go
    // After existing repos:
    customerTokenRepo := repository.NewCustomerTokenRepository(db)

    // After existing services:
    emailService := service.NewEmailService(cfg.Resend)
    customerAuthService := service.NewCustomerAuthService(
        customerRepo, customerTokenRepo, emailService,
        cfg.JWT, cfg.Google, cfg.Turnstile,
    )

    // After existing handlers:
    customerAuthHandler := handler.NewCustomerAuthHandler(customerAuthService)
    ```

    Update the `SetupRouter` call to pass `customerAuthHandler` as the new parameter.
  </action>
  <verify>
    Run `cd server && go build ./...` to confirm everything compiles. Run `grep -n "customerAuth" server/internal/api/handler/router.go` to verify routes are registered. Run `grep -n "customerAuthHandler\|customerAuthService\|emailService" server/cmd/api/main.go` to verify wiring.
  </verify>
  <done>
    CustomerAuthHandler has handlers for all 9 auth endpoints. Router registers all customer auth routes under /api/auth/customer/. main.go creates CustomerTokenRepository, EmailService, CustomerAuthService, CustomerAuthHandler and wires them into the router. Go compiles cleanly. All AUTH-01 through AUTH-05 backend requirements are implemented.
  </done>
</task>

</tasks>

<verification>
- `cd server && go build ./...` passes with zero errors
- `grep -c "/api/auth/customer" server/internal/api/handler/router.go` returns 9+ route registrations
- `grep "NewCustomerAuthService\|NewEmailService\|NewCustomerTokenRepository" server/cmd/api/main.go` shows all wiring
- `grep "verifyTurnstile\|Turnstile" server/internal/service/customer_auth_service.go` shows Turnstile integration
- `grep "resend\|SendVerification\|SendPasswordReset" server/internal/service/email_service.go` shows email integration
- `grep "oauth2\|GoogleCallback\|google.Endpoint" server/internal/service/customer_auth_service.go` shows Google OAuth
</verification>

<success_criteria>
1. All 9 customer auth API endpoints compile and are routed (signup, login, verify-email GET/POST, resend-verification, forgot-password, reset-password, google, google/callback)
2. Turnstile server-side verification is called on signup, login, and forgot-password endpoints
3. Email verification uses two-step flow (GET checks validity, POST consumes token)
4. Google OAuth uses state cookie for CSRF protection
5. Password reset validates token expiry and marks token used
6. All services are wired in main.go with env var configuration
7. `go build ./...` compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-auth-foundation/05-02-SUMMARY.md`
</output>
