---
phase: 06-multi-tenant-isolation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/migrations/012_tenant_isolation.up.sql
  - server/migrations/012_tenant_isolation.down.sql
  - server/internal/domain/models.go
  - server/internal/repository/device_repo.go
  - server/internal/repository/connection_repo.go
  - server/internal/repository/device_share_repo.go
  - server/internal/repository/customer_repo.go
  - server/internal/repository/pairing_repo.go
autonomous: true
requirements:
  - TENANT-01
  - TENANT-02
  - TENANT-03

must_haves:
  truths:
    - "devices table has a customer_id FK column referencing customers(id)"
    - "device_shares table exists with per-permission boolean columns"
    - "pairing_codes table has a customer_id FK column for assigning devices to customers"
    - "proxy_connections.customer_id is backfilled from device ownership after migration"
    - "Device domain model includes CustomerID field"
    - "DeviceShare domain model exists with all permission fields"
    - "DeviceRepository has ListByCustomer and GetByIDForCustomer methods"
    - "ConnectionRepository has ListByCustomer and GetByIDForCustomer methods"
    - "DeviceShareRepository has full CRUD plus GetByDeviceAndCustomer"
    - "PairingCode domain model includes CustomerID field"
    - "Existing devices are migrated to a new customer account for the operator"
  artifacts:
    - path: "server/migrations/012_tenant_isolation.up.sql"
      provides: "Schema changes for tenant isolation"
      contains: "device_shares"
    - path: "server/internal/domain/models.go"
      provides: "DeviceShare model, Device.CustomerID, PairingCode.CustomerID"
      contains: "DeviceShare"
    - path: "server/internal/repository/device_share_repo.go"
      provides: "Device share CRUD repository"
      contains: "DeviceShareRepository"
    - path: "server/internal/repository/device_repo.go"
      provides: "Customer-scoped device queries"
      contains: "ListByCustomer"
    - path: "server/internal/repository/connection_repo.go"
      provides: "Customer-scoped connection queries"
      contains: "ListByCustomer"
  key_links:
    - from: "server/migrations/012_tenant_isolation.up.sql"
      to: "server/internal/domain/models.go"
      via: "Schema columns map to Go struct fields"
      pattern: "customer_id.*UUID"
    - from: "server/internal/repository/device_repo.go"
      to: "server/internal/domain/models.go"
      via: "ListByCustomer returns []domain.Device filtered by customer_id"
      pattern: "ListByCustomer.*uuid\\.UUID"
---

<objective>
Create the database schema, domain models, and repository methods for multi-tenant isolation.

Purpose: Establish the data layer foundation that all backend handlers and frontend components will depend on. Without customer_id on devices, the device_shares table, and customer-scoped repository queries, no tenant isolation is possible.

Output: Migration 012 with device ownership + sharing schema, updated domain models (Device.CustomerID, DeviceShare, PairingCode.CustomerID), and repository methods for customer-scoped CRUD on devices, connections, and shares.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/06-multi-tenant-isolation/06-CONTEXT.md
@.planning/phases/06-multi-tenant-isolation/06-RESEARCH.md

@server/internal/domain/models.go
@server/internal/repository/device_repo.go
@server/internal/repository/connection_repo.go
@server/internal/repository/customer_repo.go
@server/migrations/011_customer_auth.up.sql

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From server/internal/domain/models.go:
```go
type Device struct {
    ID              uuid.UUID    `json:"id" db:"id"`
    Name            string       `json:"name" db:"name"`
    // ... (all existing fields)
    RelayServerID   *uuid.UUID   `json:"relay_server_id" db:"relay_server_id"`
    RelayServerIP   string       `json:"relay_server_ip" db:"-"`
    AutoRotateMinutes int        `json:"auto_rotate_minutes" db:"auto_rotate_minutes"`
    CreatedAt       time.Time    `json:"created_at" db:"created_at"`
    UpdatedAt       time.Time    `json:"updated_at" db:"updated_at"`
}

type Customer struct {
    ID            uuid.UUID `json:"id" db:"id"`
    Name          string    `json:"name" db:"name"`
    Email         string    `json:"email" db:"email"`
    Active        bool      `json:"active" db:"active"`
    // ... auth fields
}

type PairingCode struct {
    ID                uuid.UUID  `json:"id" db:"id"`
    Code              string     `json:"code" db:"code"`
    DeviceAuthToken   string     `json:"-" db:"device_auth_token"`
    ClaimedByDeviceID *uuid.UUID `json:"claimed_by_device_id" db:"claimed_by_device_id"`
    CreatedBy         *uuid.UUID `json:"created_by" db:"created_by"`
    RelayServerID     *uuid.UUID `json:"relay_server_id" db:"relay_server_id"`
    ReassignDeviceID  *uuid.UUID `json:"reassign_device_id" db:"reassign_device_id"`
    // ...
}

type ProxyConnection struct {
    ID             uuid.UUID  `json:"id" db:"id"`
    DeviceID       uuid.UUID  `json:"device_id" db:"device_id"`
    CustomerID     *uuid.UUID `json:"customer_id" db:"customer_id"`
    // ...
}
```

From server/internal/repository/device_repo.go:
```go
const deviceSelectColumns = `d.id, d.name, d.description, d.android_id, d.status,
    COALESCE(host(d.cellular_ip),'') as cellular_ip, ...
    d.auto_rotate_minutes, d.created_at, d.updated_at`

const deviceFromJoin = `FROM devices d LEFT JOIN relay_servers rs ON d.relay_server_id = rs.id`

func (r *DeviceRepository) List(ctx context.Context) ([]domain.Device, error)
func (r *DeviceRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Device, error)
func (r *DeviceRepository) scanDevice(row pgx.Row) (*domain.Device, error)
func (r *DeviceRepository) scanDeviceRow(rows pgx.Rows) (*domain.Device, error)
```

From server/internal/repository/connection_repo.go:
```go
const connSelectCols = `id, device_id, customer_id, username, password_hash, password_plain, ip_whitelist,
    bandwidth_limit, bandwidth_used, active, proxy_type, base_port, http_port, socks5_port,
    expires_at, created_at, updated_at`

func (r *ConnectionRepository) GetByID(ctx, id) (*domain.ProxyConnection, error)
func (r *ConnectionRepository) ListByDevice(ctx, deviceID) ([]domain.ProxyConnection, error)
```

From server/internal/repository/customer_repo.go:
```go
func (r *CustomerRepository) GetByID(ctx, id) (*domain.Customer, error)
func (r *CustomerRepository) GetByEmail(ctx, email) (*domain.Customer, error)
func (r *CustomerRepository) List(ctx) ([]domain.Customer, error)
func (r *CustomerRepository) Create(ctx, c) error
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 012 and update domain models</name>
  <files>
    server/migrations/012_tenant_isolation.up.sql
    server/migrations/012_tenant_isolation.down.sql
    server/internal/domain/models.go
  </files>
  <action>
Create migration 012_tenant_isolation.up.sql with:

1. Add `customer_id UUID REFERENCES customers(id) ON DELETE SET NULL` to `devices` table
2. Add `customer_id UUID REFERENCES customers(id) ON DELETE SET NULL` to `pairing_codes` table
3. Create index `idx_devices_customer` on `devices(customer_id)`
4. Create `device_shares` table:
   - `id UUID PRIMARY KEY DEFAULT uuid_generate_v4()`
   - `device_id UUID NOT NULL REFERENCES devices(id) ON DELETE CASCADE`
   - `owner_id UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE`
   - `shared_with UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE`
   - `can_rename BOOLEAN NOT NULL DEFAULT FALSE`
   - `can_manage_ports BOOLEAN NOT NULL DEFAULT FALSE`
   - `can_download_configs BOOLEAN NOT NULL DEFAULT FALSE`
   - `can_rotate_ip BOOLEAN NOT NULL DEFAULT FALSE`
   - `created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`
   - `updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`
   - `UNIQUE (device_id, shared_with)`
5. Create indexes: `idx_device_shares_shared_with` on `device_shares(shared_with)`, `idx_device_shares_device` on `device_shares(device_id)`
6. Migration data seed:
   - Create a new customer record for the current operator using the first admin user's email: `INSERT INTO customers (id, name, email, active, email_verified) SELECT uuid_generate_v4(), u.name, u.email, true, true FROM users u WHERE u.role = 'admin' LIMIT 1 ON CONFLICT (email) DO NOTHING`
   - Then get that customer's ID and stamp all existing devices: `UPDATE devices SET customer_id = (SELECT c.id FROM customers c JOIN users u ON LOWER(c.email) = LOWER(u.email) WHERE u.role = 'admin' LIMIT 1)`
   - Backfill proxy_connections.customer_id from device ownership: `UPDATE proxy_connections pc SET customer_id = d.customer_id FROM devices d WHERE pc.device_id = d.id AND pc.customer_id IS NULL`

Create 012_tenant_isolation.down.sql that reverses: drop device_shares, remove customer_id from devices and pairing_codes, drop indexes.

Update `server/internal/domain/models.go`:

1. Add `CustomerID *uuid.UUID` field to Device struct (after AutoRotateMinutes): `CustomerID *uuid.UUID \`json:"customer_id" db:"customer_id"\``
2. Add `CustomerID *uuid.UUID` field to PairingCode struct: `CustomerID *uuid.UUID \`json:"customer_id" db:"customer_id"\``
3. Add new DeviceShare struct:
```go
type DeviceShare struct {
    ID                uuid.UUID  `json:"id" db:"id"`
    DeviceID          uuid.UUID  `json:"device_id" db:"device_id"`
    OwnerID           uuid.UUID  `json:"owner_id" db:"owner_id"`
    SharedWith        uuid.UUID  `json:"shared_with" db:"shared_with"`
    CanRename         bool       `json:"can_rename" db:"can_rename"`
    CanManagePorts    bool       `json:"can_manage_ports" db:"can_manage_ports"`
    CanDownloadConfigs bool      `json:"can_download_configs" db:"can_download_configs"`
    CanRotateIP       bool       `json:"can_rotate_ip" db:"can_rotate_ip"`
    CreatedAt         time.Time  `json:"created_at" db:"created_at"`
    UpdatedAt         time.Time  `json:"updated_at" db:"updated_at"`
}
```
4. Add `CustomerID *uuid.UUID` to CreatePairingCodeRequest: `CustomerID *uuid.UUID \`json:"customer_id"\``

IMPORTANT: When adding CustomerID to Device struct, update the `deviceSelectColumns` constant in device_repo.go to include `d.customer_id`. Also update `scanDevice` and `scanDeviceRow` to scan the new column. Place CustomerID right after auto_rotate_minutes in both the struct and the SQL column list so scan order matches.
  </action>
  <verify>
    <automated>cd server && go build ./...</automated>
  </verify>
  <done>Migration 012 exists with device ownership schema, device_shares table, and data backfill. Domain models include CustomerID on Device and PairingCode, and the DeviceShare struct. Code compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add customer-scoped repository methods and DeviceShareRepository</name>
  <files>
    server/internal/repository/device_repo.go
    server/internal/repository/connection_repo.go
    server/internal/repository/device_share_repo.go
    server/internal/repository/customer_repo.go
    server/internal/repository/pairing_repo.go
  </files>
  <action>
**device_repo.go** -- Add these methods:

1. `ListByCustomer(ctx context.Context, customerID uuid.UUID) ([]domain.Device, error)` -- Returns devices the customer owns OR has been shared with. Use UNION query:
```sql
SELECT {deviceSelectColumns} {deviceFromJoin} WHERE d.customer_id = $1
UNION
SELECT {deviceSelectColumns} {deviceFromJoin}
INNER JOIN device_shares ds ON ds.device_id = d.id WHERE ds.shared_with = $1
ORDER BY name ASC
```
Use the existing `scanDeviceRow` to scan results.

2. `GetByIDForCustomer(ctx context.Context, deviceID uuid.UUID, customerID uuid.UUID) (*domain.Device, error)` -- Gets a single device by ID, but only if customer owns it or has a share. Return the device or pgx.ErrNoRows if not accessible:
```sql
SELECT {deviceSelectColumns} {deviceFromJoin}
WHERE d.id = $1 AND (d.customer_id = $2 OR EXISTS (
    SELECT 1 FROM device_shares ds WHERE ds.device_id = d.id AND ds.shared_with = $2
))
```

3. Update `Create` method to include `customer_id` in the INSERT statement and pass `d.CustomerID` as the parameter.

**connection_repo.go** -- Add these methods:

1. `ListByCustomer(ctx context.Context, customerID uuid.UUID) ([]domain.ProxyConnection, error)` -- Returns connections where customer_id matches:
```sql
SELECT {connSelectCols} FROM proxy_connections WHERE customer_id = $1 ORDER BY created_at DESC
```

2. `GetByIDForCustomer(ctx context.Context, connID uuid.UUID, customerID uuid.UUID) (*domain.ProxyConnection, error)` -- Gets a connection by ID but only if customer_id matches OR the connection's device is owned/shared with the customer:
```sql
SELECT {connSelectCols} FROM proxy_connections pc
WHERE pc.id = $1 AND (pc.customer_id = $2 OR EXISTS (
    SELECT 1 FROM devices d WHERE d.id = pc.device_id AND d.customer_id = $2
) OR EXISTS (
    SELECT 1 FROM device_shares ds WHERE ds.device_id = pc.device_id AND ds.shared_with = $2
))
```

3. `ListByDeviceForCustomer(ctx context.Context, deviceID uuid.UUID, customerID uuid.UUID) ([]domain.ProxyConnection, error)` -- Like ListByDevice but with ownership check on device.

**device_share_repo.go** -- Create new file:

```go
package repository

type DeviceShareRepository struct {
    db *DB
}

func NewDeviceShareRepository(db *DB) *DeviceShareRepository { ... }
```

Methods:
1. `Create(ctx, share *domain.DeviceShare) error` -- INSERT with all fields
2. `GetByID(ctx, id uuid.UUID) (*domain.DeviceShare, error)` -- SELECT by ID
3. `GetByDeviceAndCustomer(ctx, deviceID uuid.UUID, customerID uuid.UUID) (*domain.DeviceShare, error)` -- SELECT WHERE device_id = $1 AND shared_with = $2
4. `ListByDevice(ctx, deviceID uuid.UUID) ([]domain.DeviceShare, error)` -- All shares for a device (owner sees these)
5. `ListByCustomer(ctx, customerID uuid.UUID) ([]domain.DeviceShare, error)` -- All shares where shared_with = $1
6. `Update(ctx, share *domain.DeviceShare) error` -- UPDATE permission booleans + updated_at by ID
7. `Delete(ctx, id uuid.UUID) error` -- DELETE by ID

Each scan function should scan: id, device_id, owner_id, shared_with, can_rename, can_manage_ports, can_download_configs, can_rotate_ip, created_at, updated_at.

**customer_repo.go** -- Add:
1. `UpdateActive(ctx context.Context, id uuid.UUID, active bool) error` -- `UPDATE customers SET active = $2, updated_at = NOW() WHERE id = $1`
2. `GetStats(ctx context.Context, id uuid.UUID) (deviceCount int, shareCount int, totalBandwidth int64, err error)` -- Three separate queries or a single query with sub-selects:
   - `SELECT COUNT(*) FROM devices WHERE customer_id = $1` for deviceCount
   - `SELECT COUNT(*) FROM device_shares WHERE owner_id = $1` for shareCount
   - `SELECT COALESCE(SUM(pc.bandwidth_used), 0) FROM proxy_connections pc JOIN devices d ON pc.device_id = d.id WHERE d.customer_id = $1` for totalBandwidth

**pairing_repo.go** -- Update:
1. Update the `Create` method to include `customer_id` in the INSERT and pass it as a parameter. Match the existing pattern used for relay_server_id.
2. Update the scan function to scan `customer_id` if not already scanned. Add `CustomerID` to the SELECT column list in existing queries.
  </action>
  <verify>
    <automated>cd server && go build ./...</automated>
  </verify>
  <done>All repository methods compile. DeviceRepository.ListByCustomer returns owned + shared devices. ConnectionRepository.ListByCustomer returns customer-scoped connections. DeviceShareRepository has full CRUD. CustomerRepository has UpdateActive and GetStats. PairingRepository supports customer_id.</done>
</task>

</tasks>

<verification>
- `cd server && go build ./...` compiles without errors
- Migration 012 SQL is syntactically valid
- Domain models match migration schema columns
- Repository scan functions handle the new customer_id column
- All new repo methods accept customerID parameter and use it in WHERE clauses
</verification>

<success_criteria>
1. Migration 012_tenant_isolation.up.sql adds customer_id to devices and pairing_codes, creates device_shares table, seeds operator customer, and backfills data
2. Device, PairingCode, and DeviceShare domain models match the schema
3. DeviceRepository.ListByCustomer returns owned + shared devices via UNION query
4. ConnectionRepository has customer-scoped query methods
5. DeviceShareRepository provides full CRUD
6. CustomerRepository has UpdateActive and GetStats
7. `go build ./...` passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-multi-tenant-isolation/06-01-SUMMARY.md`
</output>
