---
phase: 03-security-and-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/migrations/010_security_monitoring.up.sql
  - server/internal/domain/models.go
  - server/internal/repository/connection_repo.go
  - server/internal/service/connection_service.go
  - server/internal/service/sync_service.go
  - server/internal/api/handler/openvpn_handler.go
  - server/internal/api/handler/device_handler.go
  - server/internal/api/handler/connection_handler.go
  - server/internal/api/handler/router.go
  - dashboard/src/lib/api.ts
  - dashboard/src/components/connections/ConnectionTable.tsx
autonomous: true
requirements:
  - SEC-01

must_haves:
  truths:
    - "OpenVPN auth endpoint validates passwords using bcrypt.CompareHashAndPassword, not plaintext comparison"
    - "New connections store bcrypt hash and do NOT expose PasswordPlain in API responses"
    - "Operator can regenerate a connection password from the dashboard and receives the new plaintext once"
    - ".ovpn download at creation/regen time includes auth-user-pass inline (via ?password= query param); subsequent downloads prompt"
    - "SOCKS5 tunnel path continues working — uses PasswordHash as the SOCKS5 credential (both tunnel and device agree on the hash string)"
    - "Migration nulls out password_plain per user decision; SOCKS5 path uses PasswordHash instead"
  artifacts:
    - path: "server/migrations/010_security_monitoring.up.sql"
      provides: "Schema changes for webhook_url, last_offline_alert_at columns"
      contains: "ALTER TABLE users ADD COLUMN"
    - path: "server/internal/api/handler/openvpn_handler.go"
      provides: "bcrypt auth swap + regenerate password endpoint"
      contains: "bcrypt.CompareHashAndPassword"
    - path: "server/internal/api/handler/connection_handler.go"
      provides: "RegeneratePassword handler"
      contains: "RegeneratePassword"
  key_links:
    - from: "server/internal/api/handler/openvpn_handler.go"
      to: "bcrypt"
      via: "CompareHashAndPassword in Auth()"
      pattern: "bcrypt\\.CompareHashAndPassword"
    - from: "server/internal/api/handler/router.go"
      to: "connection_handler.go"
      via: "POST /connections/:id/regenerate-password route"
      pattern: "regenerate-password"
    - from: "dashboard/src/components/connections/ConnectionTable.tsx"
      to: "dashboard/src/lib/api.ts"
      via: "regeneratePassword API call"
      pattern: "regeneratePassword"
---

<objective>
Remove plaintext password storage and comparison from OpenVPN authentication, migrate the SOCKS5 credential path to use PasswordHash, and add a regenerate-password endpoint so operators can securely manage credentials.

Purpose: SEC-01 requires that OpenVPN auth uses bcrypt instead of plaintext comparison. After this plan, the Auth() handler uses bcrypt.CompareHashAndPassword. The migration nulls out password_plain (per user decision). The SOCKS5 tunnel path switches to using PasswordHash as its credential — both tunnel server and Android device agree on the bcrypt hash string as the SOCKS5 auth token (a string-to-string comparison, not a hash verification). A new regenerate-password endpoint generates a fresh random password, stores only the bcrypt hash, and returns the plaintext once. The .ovpn download supports a `?password=` query parameter for embedding inline credentials at creation/regen time. The dashboard gets a "Regenerate Password" button on each connection row. The migration also adds columns needed by Plan 03-02 (webhook_url on users, last_offline_alert_at on devices).

Output: Migration SQL, updated auth handler, SOCKS5 path migration, regenerate endpoint, dashboard regenerate button.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-and-monitoring/03-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From server/internal/domain/models.go:
```go
type ProxyConnection struct {
    ID             uuid.UUID  `json:"id" db:"id"`
    DeviceID       uuid.UUID  `json:"device_id" db:"device_id"`
    CustomerID     *uuid.UUID `json:"customer_id" db:"customer_id"`
    Username       string     `json:"username" db:"username"`
    PasswordHash   string     `json:"-" db:"password_hash"`
    PasswordPlain  string     `json:"-" db:"password_plain"`
    Password       string     `json:"password,omitempty" db:"-"` // plaintext only on creation response
    IPWhitelist    []string   `json:"ip_whitelist" db:"ip_whitelist"`
    BandwidthLimit int64      `json:"bandwidth_limit" db:"bandwidth_limit"`
    BandwidthUsed  int64      `json:"bandwidth_used" db:"bandwidth_used"`
    Active         bool       `json:"active" db:"active"`
    ProxyType      string     `json:"proxy_type" db:"proxy_type"`
    // ... port fields, timestamps
}

type User struct {
    ID           uuid.UUID `json:"id" db:"id"`
    Email        string    `json:"email" db:"email"`
    PasswordHash string    `json:"-" db:"password_hash"`
    Name         string    `json:"name" db:"name"`
    Role         string    `json:"role" db:"role"`
    CreatedAt    time.Time `json:"created_at" db:"created_at"`
    UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`
}
```

From server/internal/api/handler/openvpn_handler.go (Auth method, line 56):
```go
// CURRENT — must change to bcrypt:
if conn.PasswordPlain != req.Password {
```

From server/internal/api/handler/openvpn_handler.go (Connect method, line 112):
```go
// CURRENT — uses PasswordPlain. Must change to PasswordHash (SOCKS5 credential migration):
"socks_pass": conn.PasswordPlain,
// CHANGE TO: "socks_pass": conn.PasswordHash,
```

From server/internal/api/handler/openvpn_handler.go (DownloadOVPN, lines 221-225):
```go
// CURRENT — embeds conn.PasswordPlain inline:
ovpn.WriteString("<auth-user-pass>\n")
ovpn.WriteString(conn.Username + "\n")
ovpn.WriteString(conn.PasswordPlain + "\n")
ovpn.WriteString("</auth-user-pass>\n")
// CHANGE TO: check for ?password= query param; embed if present, omit block if absent
```

From server/internal/service/connection_service.go (Create, lines 88-90):
```go
// CURRENT — populates PasswordPlain. Remove after migration:
PasswordPlain:  req.Password,
Password:       req.Password, // Return plaintext on creation only
// CHANGE TO: remove PasswordPlain line, keep Password
```

From server/internal/service/connection_service.go (GetByID, line 142):
```go
// CURRENT — exposes plaintext in API response. Must STOP doing this:
conn.Password = conn.PasswordPlain
```

From server/internal/api/handler/connection_handler.go:
```go
type ConnectionHandler struct {
    connService *service.ConnectionService
}
// Methods: Create, List, GetByID, SetActive, Delete
```

From server/internal/api/handler/router.go:
```go
// Dashboard routes (JWT protected) — add regenerate-password here:
dashboard.DELETE("/connections/:id", connHandler.Delete)
// After this line, add:
// dashboard.POST("/connections/:id/regenerate-password", connHandler.RegeneratePassword)
```

From dashboard/src/lib/api.ts:
```typescript
export const api = {
  connections: {
    list: (token, deviceId?) => ...,
    create: (token, data) => ...,
    setActive: (token, id, active) => ...,
    delete: (token, id) => ...,
    downloadOVPN: async (token, id) => ...,
  },
}
```

From server/internal/api/handler/device_handler.go (heartbeat credentials, lines 163-166):
```go
// CURRENT — sends PasswordPlain to device for SOCKS5 auth. Must change to PasswordHash:
if conn.Active && conn.PasswordPlain != "" {
    creds = append(creds, domain.ProxyCredential{
        Username: conn.Username,
        Password: conn.PasswordPlain,
    })
}
// CHANGE TO: use conn.PasswordHash instead of conn.PasswordPlain, check PasswordHash != ""
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration SQL, bcrypt auth swap, and SOCKS5 credential migration</name>
  <files>
    server/migrations/010_security_monitoring.up.sql
    server/internal/api/handler/openvpn_handler.go
    server/internal/api/handler/device_handler.go
    server/internal/service/connection_service.go
    server/internal/service/sync_service.go
  </files>
  <action>
**Migration (010_security_monitoring.up.sql):**
Create the migration file with these statements:
```sql
-- Add webhook_url to users (per-operator, used by Plan 03-02)
ALTER TABLE users ADD COLUMN IF NOT EXISTS webhook_url TEXT;

-- Add last_offline_alert_at to devices (cooldown tracking, used by Plan 03-02)
ALTER TABLE devices ADD COLUMN IF NOT EXISTS last_offline_alert_at TIMESTAMPTZ;

-- Null out password_plain per user decision (SOCKS5 path now uses password_hash as credential)
UPDATE proxy_connections SET password_plain = NULL WHERE password_plain IS NOT NULL;

-- Make password_plain nullable
ALTER TABLE proxy_connections ALTER COLUMN password_plain DROP NOT NULL;
ALTER TABLE proxy_connections ALTER COLUMN password_plain DROP DEFAULT;
```
Per the locked user decision: "Batch migration on deploy: one-time script hashes all existing PasswordPlain values to bcrypt, then nulls out the plaintext field." The existing `connection_service.go Create()` already hashes to bcrypt at creation time, so all rows already have valid `password_hash` values. The migration nulls `password_plain`.

**SOCKS5 credential migration — use PasswordHash as SOCKS5 auth token:**
After nulling `password_plain`, the SOCKS5 tunnel path needs a credential. The solution: use the `password_hash` string (the bcrypt hash itself) as the SOCKS5 credential on both sides. The tunnel server sends `conn.PasswordHash` as `socks_pass` to the device. The device's SOCKS5 proxy receives the hash via heartbeat and uses it for literal string comparison. This is NOT "storing plaintext" — the bcrypt hash is an opaque derived token used as a shared secret between tunnel and device. Change these paths:

1. `openvpn_handler.go Connect()` line 112: Change `"socks_pass": conn.PasswordPlain` to `"socks_pass": conn.PasswordHash`
2. `device_handler.go Heartbeat()` lines 163-166: Change `conn.PasswordPlain` to `conn.PasswordHash` and condition to `conn.PasswordHash != ""`
3. `sync_service.go` line 85: Change `PasswordPlain: c.PasswordPlain` to `PasswordPlain: c.PasswordHash` (the sync struct field name stays for wire compat, but the value is now the hash)
4. `connection_service.go Create()` line 89: Remove `PasswordPlain: req.Password` — no longer stored

**openvpn_handler.go Auth() — swap to bcrypt (line 56):**
Replace the plaintext comparison:
```go
if conn.PasswordPlain != req.Password {
```
With bcrypt comparison:
```go
if err := bcrypt.CompareHashAndPassword([]byte(conn.PasswordHash), []byte(req.Password)); err != nil {
```
Add `"golang.org/x/crypto/bcrypt"` to the imports (already in go.mod).

**openvpn_handler.go DownloadOVPN() — conditional inline credentials (lines 221-225):**
Per the locked user decision: ".ovpn file includes auth-user-pass inline at creation/regen time." At creation and regeneration time, the plaintext password IS available (just generated). The download endpoint should support a `?password=` query parameter. When present, embed `<auth-user-pass>` inline with the username and provided password. When absent (subsequent downloads), omit the block and the `auth-user-pass` directive on line 214 will prompt the user.

Replace the hardcoded `<auth-user-pass>` block:
```go
// Embed credentials inline so the user isn't prompted
ovpn.WriteString("<auth-user-pass>\n")
ovpn.WriteString(conn.Username + "\n")
ovpn.WriteString(conn.PasswordPlain + "\n")
ovpn.WriteString("</auth-user-pass>\n")
ovpn.WriteString("\n")
```
With conditional embedding:
```go
// Embed credentials inline only when ?password= is provided (creation/regen time)
if passParam := c.Query("password"); passParam != "" {
    ovpn.WriteString("<auth-user-pass>\n")
    ovpn.WriteString(conn.Username + "\n")
    ovpn.WriteString(passParam + "\n")
    ovpn.WriteString("</auth-user-pass>\n")
    ovpn.WriteString("\n")
}
```

**connection_service.go — stop exposing PasswordPlain in API responses:**
In `GetByID()` (line 142), `ListByDevice()` (line 152), and `List()` (line 163), remove the lines that copy PasswordPlain to Password:
```go
// REMOVE: conn.Password = conn.PasswordPlain
```
After this change, the `password` JSON field will only be populated on the creation response (where it's set explicitly to `req.Password` in Create()). Existing connections will return `password: ""` (omitempty means it won't appear in JSON).

**Files also modified for SOCKS5 migration (in addition to files listed above):**
- `server/internal/api/handler/device_handler.go` — heartbeat credentials path
- `server/internal/service/sync_service.go` — sync path
  </action>
  <verify>
    <automated>cd server && go build ./... 2>&1 | head -20</automated>
  </verify>
  <done>
    - OpenVPN Auth() uses bcrypt.CompareHashAndPassword instead of plaintext comparison
    - .ovpn download embeds inline auth-user-pass when ?password= query param provided (creation/regen time); prompts otherwise
    - API responses for GetByID/List/ListByDevice do not expose password field
    - Migration nulls password_plain column per user decision
    - SOCKS5 paths (Connect socks_pass, heartbeat credentials, sync) use PasswordHash as credential
    - Migration file adds webhook_url and last_offline_alert_at columns
  </done>
</task>

<task type="auto">
  <name>Task 2: Regenerate password endpoint and dashboard button</name>
  <files>
    server/internal/repository/connection_repo.go
    server/internal/service/connection_service.go
    server/internal/api/handler/connection_handler.go
    server/internal/api/handler/router.go
    dashboard/src/lib/api.ts
    dashboard/src/components/connections/ConnectionTable.tsx
  </files>
  <action>
**connection_repo.go — add UpdatePasswordHash method:**
```go
func (r *ConnectionRepository) UpdatePasswordHash(ctx context.Context, id uuid.UUID, hash string) error {
    query := `UPDATE proxy_connections SET password_hash = $2, updated_at = NOW() WHERE id = $1`
    _, err := r.db.Pool.Exec(ctx, query, id, hash)
    return err
}
```
Note: Only the hash is stored. `password_plain` is NULL (per migration). The SOCKS5 tunnel path uses the hash string itself as the credential.

**connection_service.go — add RegeneratePassword method:**
```go
func (s *ConnectionService) RegeneratePassword(ctx context.Context, id uuid.UUID) (string, error) {
    // Generate 16-character random password
    b := make([]byte, 12)
    if _, err := rand.Read(b); err != nil {
        return "", fmt.Errorf("generate password: %w", err)
    }
    newPass := base64.URLEncoding.EncodeToString(b)[:16]

    hash, err := bcrypt.GenerateFromPassword([]byte(newPass), 12)
    if err != nil {
        return "", fmt.Errorf("hash password: %w", err)
    }

    if err := s.connRepo.UpdatePasswordHash(ctx, id, string(hash)); err != nil {
        return "", fmt.Errorf("update password: %w", err)
    }

    // Sync credentials to device via heartbeat (device will get new hash as SOCKS5 credential)
    conn, err := s.connRepo.GetByID(ctx, id)
    if err == nil && s.syncService != nil {
        conns, err := s.connRepo.ListByDevice(ctx, conn.DeviceID)
        if err == nil {
            go s.syncService.SyncConnections(conn.DeviceID, conns)
        }
    }

    return newPass, nil
}
```
Add imports: `"crypto/rand"`, `"encoding/base64"`, `"golang.org/x/crypto/bcrypt"` (bcrypt already imported).

**connection_handler.go — add RegeneratePassword handler:**
```go
func (h *ConnectionHandler) RegeneratePassword(c *gin.Context) {
    id, err := uuid.Parse(c.Param("id"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid connection id"})
        return
    }

    newPass, err := h.connService.RegeneratePassword(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"password": newPass})
}
```

**router.go — wire the new endpoint:**
After `dashboard.DELETE("/connections/:id", connHandler.Delete)` add:
```go
dashboard.POST("/connections/:id/regenerate-password", connHandler.RegeneratePassword)
```

**dashboard/src/lib/api.ts — add regeneratePassword function:**
In the `connections` object, add after `delete`:
```typescript
regeneratePassword: (token: string, id: string) =>
    request<{ password: string }>(`/connections/${id}/regenerate-password`, { method: 'POST', token }),
```

**dashboard/src/components/connections/ConnectionTable.tsx — add Regenerate button:**
Add a "Regenerate" button (small, variant="ghost") on each connection row, next to the existing action buttons. When clicked:
1. Call `api.connections.regeneratePassword(token, connection.id)`
2. Show the new password in a small dialog/alert with a copy button
3. Display a note: "Save this password now. It will not be shown again."
4. Use a local state variable (e.g., `regeneratedPassword`) to hold the one-time password
5. Clear the state when the dialog is closed

Use the existing `Copy` icon from lucide-react. Use a simple AlertDialog from shadcn/ui (already installed) for the password display.

Import `RefreshCw` from lucide-react for the button icon. Follow the existing pattern of inline state management (copiedKey with 2s timeout) used for copy buttons in this component.
  </action>
  <verify>
    <automated>cd server && go build ./... 2>&1 | head -20</automated>
  </verify>
  <done>
    - POST /api/connections/:id/regenerate-password returns new plaintext password once
    - Password hash updated in DB with bcrypt cost 12; password_plain stays NULL
    - SOCKS5 tunnel path uses PasswordHash as credential (no plaintext stored)
    - Dashboard shows "Regenerate" button on each connection row
    - Clicking Regenerate shows new password in dialog with copy button and "will not be shown again" warning
    - Sync service notified so device gets new hash as SOCKS5 credential on next heartbeat
  </done>
</task>

</tasks>

<verification>
1. `cd server && go build ./...` compiles without errors
2. Auth() in openvpn_handler.go uses `bcrypt.CompareHashAndPassword` (grep confirms)
3. DownloadOVPN conditionally embeds `<auth-user-pass>` only when `?password=` query param is present (grep confirms `c.Query("password")`)
4. Connection API responses do not include `password` field for existing connections (GetByID, List)
5. RegeneratePassword endpoint exists in router.go
6. Dashboard ConnectionTable has a Regenerate button
7. Migration file nulls password_plain and creates webhook_url and last_offline_alert_at columns
8. SOCKS5 paths (Connect, Heartbeat, sync) use `conn.PasswordHash` not `conn.PasswordPlain` (grep confirms)
</verification>

<success_criteria>
- OpenVPN authentication uses bcrypt hash comparison, not plaintext string comparison
- Operator can regenerate a password from the dashboard and sees the new password exactly once
- .ovpn download at creation/regen time includes inline auth-user-pass (via ?password= param); subsequent downloads prompt
- Migration nulls password_plain per locked user decision
- SOCKS5/tunnel paths use PasswordHash as credential (both tunnel server and device agree on hash string)
- Go server compiles cleanly
- Migration file is ready for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-and-monitoring/03-01-SUMMARY.md`
</output>
