---
phase: 06-multi-tenant-isolation
plan: 03
type: execute
wave: 3
depends_on:
  - 06-02
files_modified:
  - dashboard/src/lib/auth.ts
  - dashboard/src/lib/api.ts
  - dashboard/src/components/dashboard/Sidebar.tsx
  - dashboard/src/app/layout.tsx
  - dashboard/src/app/devices/page.tsx
  - dashboard/src/app/admin/customers/page.tsx
autonomous: false
requirements:
  - TENANT-01
  - TENANT-02
  - TENANT-03

must_haves:
  truths:
    - "Customer login shows only Devices nav item in sidebar -- no admin items visible"
    - "Admin login shows full sidebar with Devices, Customers, and other admin nav items"
    - "Customer device list page shows only their assigned devices"
    - "Admin has a customer management page listing all customers with detail view"
    - "Admin can suspend and activate customers from the customer detail view"
    - "Admin can assign a customer when creating a pairing code"
  artifacts:
    - path: "dashboard/src/lib/auth.ts"
      provides: "Role helper functions (isAdmin, isCustomer, getRole)"
      contains: "isAdmin"
    - path: "dashboard/src/components/dashboard/Sidebar.tsx"
      provides: "Role-aware sidebar navigation"
      contains: "adminNavItems"
    - path: "dashboard/src/app/admin/customers/page.tsx"
      provides: "Admin customer management page"
      contains: "Customers"
  key_links:
    - from: "dashboard/src/lib/auth.ts"
      to: "dashboard/src/components/dashboard/Sidebar.tsx"
      via: "isAdmin() determines which nav items render"
      pattern: "isAdmin"
    - from: "dashboard/src/app/admin/customers/page.tsx"
      to: "dashboard/src/lib/api.ts"
      via: "Fetches customer list and detail from API"
      pattern: "customers"
---

<objective>
Make the dashboard frontend role-aware so customers see only their data and admin-only UI is hidden.

Purpose: The backend from Plan 02 enforces tenant isolation, but without frontend changes, customers would see confusing admin navigation items (that return 403) and no customer-specific experience. This plan delivers the user-facing side of multi-tenancy.

Output: Role helpers in auth.ts, role-gated sidebar, admin customer management page with suspend/activate, pairing code customer assignment, and a human-verified complete flow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/06-multi-tenant-isolation/06-CONTEXT.md
@.planning/phases/06-multi-tenant-isolation/06-02-SUMMARY.md

@dashboard/src/lib/auth.ts
@dashboard/src/lib/api.ts
@dashboard/src/components/dashboard/Sidebar.tsx
@dashboard/src/app/devices/page.tsx
@dashboard/src/app/devices/[id]/page.tsx

<interfaces>
<!-- Current frontend auth and API patterns. -->

From dashboard/src/lib/auth.ts:
```typescript
const TOKEN_KEY = 'pocketproxy_token'
const USER_KEY = 'pocketproxy_user'

export function getToken(): string | null
export function setAuth(token: string, user: { id: string; email: string; name: string; role: string }): void
export function getUser(): { id: string; email: string; name: string; role: string } | null
export function clearAuth(): void
export function isAuthenticated(): boolean
```

From dashboard/src/components/dashboard/Sidebar.tsx:
```typescript
const navItems = [
  { href: '/devices', label: 'Devices', icon: Smartphone },
]
// Single static nav list, no role awareness
```

From dashboard/src/lib/api.ts:
```typescript
// Existing pattern for API calls:
async function apiFetch(path: string, options?: RequestInit) {
  const token = getToken()
  // ... adds Authorization header, handles 401 redirect
}

// Existing customer API (CRUD):
export const customers = {
  list: () => apiFetch('/customers'),
  create: (data) => apiFetch('/customers', { method: 'POST', body: ... }),
  getById: (id) => apiFetch(`/customers/${id}`),
  update: (id, data) => apiFetch(`/customers/${id}`, { method: 'PUT', body: ... }),
}
```

Backend endpoints available from Plan 02:
```
GET  /api/customers           (admin only)
GET  /api/customers/:id       (admin only -- enriched with stats)
POST /api/customers/:id/suspend   (admin only)
POST /api/customers/:id/activate  (admin only)
POST /api/pairing-codes       (admin only -- now accepts customer_id)
GET  /api/devices              (role-branched -- customer gets filtered)
GET  /api/device-shares        (authenticated)
POST /api/device-shares        (authenticated)
PUT  /api/device-shares/:id    (authenticated)
DELETE /api/device-shares/:id  (authenticated)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add role helpers, role-aware sidebar, API methods, and admin customer management page</name>
  <files>
    dashboard/src/lib/auth.ts
    dashboard/src/lib/api.ts
    dashboard/src/components/dashboard/Sidebar.tsx
    dashboard/src/app/admin/customers/page.tsx
    dashboard/src/app/devices/page.tsx
    dashboard/src/app/layout.tsx
  </files>
  <action>
**dashboard/src/lib/auth.ts** -- Add role helper functions after existing exports:

```typescript
export function getRole(): string | null {
  const user = getUser()
  return user ? user.role : null
}

export function isAdmin(): boolean {
  const role = getRole()
  return role === 'admin' || role === 'operator'
}

export function isCustomer(): boolean {
  return getRole() === 'customer'
}
```

**dashboard/src/lib/api.ts** -- Add new API methods:

1. Add to the existing `customers` namespace:
   - `getDetail: (id: string) => apiFetch(\`/customers/${id}\`)` -- returns enriched customer with stats (device_count, share_count, total_bandwidth)
   - `suspend: (id: string) => apiFetch(\`/customers/${id}/suspend\`, { method: 'POST' })`
   - `activate: (id: string) => apiFetch(\`/customers/${id}/activate\`, { method: 'POST' })`

2. Add `deviceShares` namespace:
```typescript
export const deviceShares = {
  list: (deviceId: string) => apiFetch(`/device-shares?device_id=${deviceId}`),
  create: (data: { device_id: string; shared_with: string; can_rename: boolean; can_manage_ports: boolean; can_download_configs: boolean; can_rotate_ip: boolean }) =>
    apiFetch('/device-shares', { method: 'POST', body: JSON.stringify(data) }),
  update: (id: string, data: { can_rename: boolean; can_manage_ports: boolean; can_download_configs: boolean; can_rotate_ip: boolean }) =>
    apiFetch(`/device-shares/${id}`, { method: 'PUT', body: JSON.stringify(data) }),
  delete: (id: string) => apiFetch(`/device-shares/${id}`, { method: 'DELETE' }),
}
```

3. Update `pairingCodes.create` to accept optional `customer_id` in the request body (add it to the data parameter type).

**dashboard/src/components/dashboard/Sidebar.tsx** -- Make role-aware:

1. Import `isAdmin` from `@/lib/auth`
2. Import `Users` and `BarChart3` icons from lucide-react
3. Define two nav item arrays:
```typescript
const adminNavItems = [
  { href: '/devices', label: 'Devices', icon: Smartphone },
  { href: '/admin/customers', label: 'Customers', icon: Users },
]

const customerNavItems = [
  { href: '/devices', label: 'Devices', icon: Smartphone },
]
```
4. In the component, use `isAdmin()` to select which array: `const navItems = isAdmin() ? adminNavItems : customerNavItems`
5. The `isAdmin()` call should be inside a useEffect or useMemo to avoid SSR issues. Since the component is already 'use client' and uses useEffect for hydration, wrap the nav selection in state:
```typescript
const [navItems, setNavItems] = useState(customerNavItems)
useEffect(() => {
  setNavItems(isAdmin() ? adminNavItems : customerNavItems)
}, [])
```

**dashboard/src/app/admin/customers/page.tsx** -- Create new admin customer management page:

1. Create directory `dashboard/src/app/admin/customers/`
2. Build the page with:
   - `'use client'` directive
   - Fetch customer list on mount using `customers.list()`
   - Display in a Table (use shadcn Table component matching DeviceTable pattern)
   - Columns: Name, Email, Status (active/suspended badge), Email Verified, Created At
   - Click row to expand/navigate to detail view
   - For simplicity, use an inline detail panel or modal (matching the single-page dashboard pattern)
   - Detail view shows: email, name, signup date, email_verified, device_count, active_shares, total_bandwidth, last_login (from customer object)
   - Suspend/Activate button that calls the appropriate API and refreshes
   - Use shadcn Badge for active (green) / suspended (red) status
   - Style consistently with existing dashboard pages (dark theme, zinc colors)

3. Ensure the `/admin/customers` route picks up the dashboard layout. Check if `dashboard/src/app/layout.tsx` wraps all routes with the Sidebar. If the layout applies globally under `/app`, the new `/admin/customers` will inherit it automatically. If not, create `dashboard/src/app/admin/layout.tsx` that imports and uses the dashboard layout pattern.

**dashboard/src/app/devices/page.tsx** -- Minor update:

1. The device list page currently fetches all devices. With the backend now role-branching, the same `GET /api/devices` call returns filtered results for customers. No fetch change needed.
2. However, hide admin-only UI elements for customers:
   - If `isCustomer()`, hide the "Add Pairing Code" or any device creation controls that exist. Customers will self-onboard in Phase 7, so for now they just see their devices.
   - If the devices page has any "Create" or "Pair" buttons, conditionally render them only when `isAdmin()`.

**Pairing code customer assignment** (admin side):
The pairing code creation form (wherever it lives -- check the existing UI) should add an optional customer dropdown when the admin creates a pairing code:
- Fetch customer list, show as a Select dropdown (optional -- "Assign to Customer")
- Pass selected `customer_id` in the create request body
- This satisfies TENANT-02: operator assigns devices to customers

Look for the pairing code creation UI. It might be a modal on the devices page or a separate section. Search for `CreateCode` or `pairing-codes` in the dashboard code to find it. Add an optional customer selector to that form.
  </action>
  <verify>
    <automated>cd dashboard && npx next build 2>&1 | tail -20</automated>
  </verify>
  <done>Role helpers (isAdmin, isCustomer) exported from auth.ts. Sidebar shows admin-only items only for admin role. Admin customer management page at /admin/customers lists customers with suspend/activate. Device shares API methods exist. Pairing code creation supports customer assignment. Dashboard builds without errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify multi-tenant isolation end-to-end</name>
  <files>
    dashboard/src/components/dashboard/Sidebar.tsx
    dashboard/src/app/admin/customers/page.tsx
  </files>
  <action>
Human verification of the complete multi-tenant isolation system. No code changes -- this is a visual and functional check.

What was built:
- Database migration with device ownership and sharing schema
- Backend middleware (AdminOnlyMiddleware, CustomerSuspensionCheck)
- Role-branching in all device/connection handlers
- Device share service and endpoints
- Role-aware sidebar (admin sees all nav, customer sees only Devices)
- Admin customer management page with suspend/activate
- Pairing code customer assignment
  </action>
  <verify>
Setup: Apply migration 012 to database, restart backend and dashboard.

Test 1 -- Customer isolation:
1. Log in as a customer account
2. Verify sidebar shows only "Devices" (no Customers, no admin items)
3. Verify device list shows only devices assigned to this customer
4. Try accessing /admin/customers directly -- should redirect or show empty/forbidden

Test 2 -- Admin experience:
1. Log in as admin
2. Verify sidebar shows Devices + Customers
3. Navigate to /admin/customers -- see list of all customers
4. Click a customer -- see detail with device count, bandwidth
5. Suspend a customer -- verify badge changes to suspended

Test 3 -- API isolation (curl):
1. Using a customer JWT, curl GET /api/devices -- should return only that customer's devices
2. Using a customer JWT, curl GET /api/stats/overview -- should return 403
3. Using a customer JWT with a device ID owned by another customer, curl GET /api/devices/{other-id} -- should return 403

Test 4 -- Pairing code assignment:
1. As admin, create a pairing code with a customer_id selected
2. Verify the pairing code response includes customer_id
  </verify>
  <done>Human confirms: customer sees only their devices, admin sees all + customer management page, cross-customer API access returns 403, pairing code customer assignment works.</done>
</task>

</tasks>

<verification>
- `cd dashboard && npx next build` completes without errors
- Customer login shows filtered sidebar
- Admin login shows full sidebar with Customers page
- Customer management page renders with table and suspend/activate
- API calls from customer JWT return only their data
</verification>

<success_criteria>
1. isAdmin() and isCustomer() helpers work correctly based on JWT role
2. Customer sidebar shows only Devices nav item
3. Admin sidebar shows Devices + Customers nav items
4. Admin customer management page lists all customers with detail view, suspend, activate
5. Pairing code creation form has optional customer assignment dropdown
6. Dashboard builds successfully
7. Human verifies end-to-end tenant isolation works
</success_criteria>

<output>
After completion, create `.planning/phases/06-multi-tenant-isolation/06-03-SUMMARY.md`
</output>
