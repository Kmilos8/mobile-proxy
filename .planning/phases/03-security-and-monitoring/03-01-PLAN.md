---
phase: 03-security-and-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/migrations/010_security_monitoring.up.sql
  - server/internal/domain/models.go
  - server/internal/repository/connection_repo.go
  - server/internal/service/connection_service.go
  - server/internal/api/handler/openvpn_handler.go
  - server/internal/api/handler/connection_handler.go
  - server/internal/api/handler/router.go
  - dashboard/src/lib/api.ts
  - dashboard/src/components/connections/ConnectionTable.tsx
autonomous: true
requirements:
  - SEC-01

must_haves:
  truths:
    - "OpenVPN auth endpoint validates passwords using bcrypt.CompareHashAndPassword, not plaintext comparison"
    - "New connections store bcrypt hash and do NOT expose PasswordPlain in API responses"
    - "Operator can regenerate a connection password from the dashboard and receives the new plaintext once"
    - ".ovpn download after regeneration prompts for credentials (no inline plaintext from DB)"
    - "SOCKS5 tunnel path continues working — PasswordPlain stays populated internally for device heartbeat and tunnel connect"
  artifacts:
    - path: "server/migrations/010_security_monitoring.up.sql"
      provides: "Schema changes for webhook_url, last_offline_alert_at columns"
      contains: "ALTER TABLE users ADD COLUMN"
    - path: "server/internal/api/handler/openvpn_handler.go"
      provides: "bcrypt auth swap + regenerate password endpoint"
      contains: "bcrypt.CompareHashAndPassword"
    - path: "server/internal/api/handler/connection_handler.go"
      provides: "RegeneratePassword handler"
      contains: "RegeneratePassword"
  key_links:
    - from: "server/internal/api/handler/openvpn_handler.go"
      to: "bcrypt"
      via: "CompareHashAndPassword in Auth()"
      pattern: "bcrypt\\.CompareHashAndPassword"
    - from: "server/internal/api/handler/router.go"
      to: "connection_handler.go"
      via: "POST /connections/:id/regenerate-password route"
      pattern: "regenerate-password"
    - from: "dashboard/src/components/connections/ConnectionTable.tsx"
      to: "dashboard/src/lib/api.ts"
      via: "regeneratePassword API call"
      pattern: "regeneratePassword"
---

<objective>
Remove plaintext password comparison from OpenVPN authentication and add a regenerate-password endpoint so operators can securely manage credentials.

Purpose: SEC-01 requires that OpenVPN auth uses bcrypt instead of plaintext comparison. After this plan, the Auth() handler uses bcrypt.CompareHashAndPassword. A new regenerate-password endpoint generates a fresh random password, stores only the bcrypt hash, and returns the plaintext once. The dashboard gets a "Regenerate Password" button on each connection row. The migration also adds columns needed by Plan 03-02 (webhook_url on users, last_offline_alert_at on devices).

Output: Migration SQL, updated auth handler, regenerate endpoint, dashboard regenerate button.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-and-monitoring/03-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From server/internal/domain/models.go:
```go
type ProxyConnection struct {
    ID             uuid.UUID  `json:"id" db:"id"`
    DeviceID       uuid.UUID  `json:"device_id" db:"device_id"`
    CustomerID     *uuid.UUID `json:"customer_id" db:"customer_id"`
    Username       string     `json:"username" db:"username"`
    PasswordHash   string     `json:"-" db:"password_hash"`
    PasswordPlain  string     `json:"-" db:"password_plain"`
    Password       string     `json:"password,omitempty" db:"-"` // plaintext only on creation response
    IPWhitelist    []string   `json:"ip_whitelist" db:"ip_whitelist"`
    BandwidthLimit int64      `json:"bandwidth_limit" db:"bandwidth_limit"`
    BandwidthUsed  int64      `json:"bandwidth_used" db:"bandwidth_used"`
    Active         bool       `json:"active" db:"active"`
    ProxyType      string     `json:"proxy_type" db:"proxy_type"`
    // ... port fields, timestamps
}

type User struct {
    ID           uuid.UUID `json:"id" db:"id"`
    Email        string    `json:"email" db:"email"`
    PasswordHash string    `json:"-" db:"password_hash"`
    Name         string    `json:"name" db:"name"`
    Role         string    `json:"role" db:"role"`
    CreatedAt    time.Time `json:"created_at" db:"created_at"`
    UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`
}
```

From server/internal/api/handler/openvpn_handler.go (Auth method, line 56):
```go
// CURRENT — must change to bcrypt:
if conn.PasswordPlain != req.Password {
```

From server/internal/api/handler/openvpn_handler.go (Connect method, line 112):
```go
// Keep using conn.PasswordPlain for SOCKS5 tunnel path — do NOT change this:
"socks_pass": conn.PasswordPlain,
```

From server/internal/api/handler/openvpn_handler.go (DownloadOVPN, line 224):
```go
// CURRENT — after regen, PasswordPlain may differ from what user expects.
// Change to remove inline auth-user-pass block (user enters manually):
ovpn.WriteString(conn.PasswordPlain + "\n")
```

From server/internal/service/connection_service.go (Create, lines 88-90):
```go
// Keep PasswordPlain populated for internal SOCKS5 path:
PasswordPlain:  req.Password,
Password:       req.Password, // Return plaintext on creation only
```

From server/internal/service/connection_service.go (GetByID, line 142):
```go
// CURRENT — exposes plaintext in API response. Must STOP doing this:
conn.Password = conn.PasswordPlain
```

From server/internal/api/handler/connection_handler.go:
```go
type ConnectionHandler struct {
    connService *service.ConnectionService
}
// Methods: Create, List, GetByID, SetActive, Delete
```

From server/internal/api/handler/router.go:
```go
// Dashboard routes (JWT protected) — add regenerate-password here:
dashboard.DELETE("/connections/:id", connHandler.Delete)
// After this line, add:
// dashboard.POST("/connections/:id/regenerate-password", connHandler.RegeneratePassword)
```

From dashboard/src/lib/api.ts:
```typescript
export const api = {
  connections: {
    list: (token, deviceId?) => ...,
    create: (token, data) => ...,
    setActive: (token, id, active) => ...,
    delete: (token, id) => ...,
    downloadOVPN: async (token, id) => ...,
  },
}
```

From server/internal/api/handler/device_handler.go (heartbeat credentials, lines 163-166):
```go
// Keep this path — device needs plaintext for its SOCKS5 proxy auth:
if conn.Active && conn.PasswordPlain != "" {
    creds = append(creds, domain.ProxyCredential{
        Username: conn.Username,
        Password: conn.PasswordPlain,
    })
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration SQL and bcrypt auth swap</name>
  <files>
    server/migrations/010_security_monitoring.up.sql
    server/internal/api/handler/openvpn_handler.go
    server/internal/service/connection_service.go
  </files>
  <action>
**Migration (010_security_monitoring.up.sql):**
Create the migration file with these statements:
```sql
-- Add webhook_url to users (per-operator, used by Plan 03-02)
ALTER TABLE users ADD COLUMN IF NOT EXISTS webhook_url TEXT;

-- Add last_offline_alert_at to devices (cooldown tracking, used by Plan 03-02)
ALTER TABLE devices ADD COLUMN IF NOT EXISTS last_offline_alert_at TIMESTAMPTZ;
```
NOTE: Do NOT null out password_plain in migration — it is still needed for the SOCKS5 tunnel path (Connect() sends it as socks_pass, device_handler.go sends it via heartbeat to the device). The research Open Question #1 confirms PasswordPlain must stay populated internally. SEC-01 success criterion is specifically about OpenVPN auth using bcrypt, not about removing PasswordPlain entirely.

**openvpn_handler.go Auth() — swap to bcrypt (line 56):**
Replace the plaintext comparison:
```go
if conn.PasswordPlain != req.Password {
```
With bcrypt comparison:
```go
if err := bcrypt.CompareHashAndPassword([]byte(conn.PasswordHash), []byte(req.Password)); err != nil {
```
Add `"golang.org/x/crypto/bcrypt"` to the imports (already in go.mod).

**openvpn_handler.go DownloadOVPN() — remove inline credentials (lines 221-225):**
Remove the `<auth-user-pass>` block that embeds conn.PasswordPlain inline. Instead, keep just `auth-user-pass` directive (already on line 214) which will prompt the user to enter credentials. The CONTEXT.md decision says ".ovpn file includes auth-user-pass inline at creation/regen time" — but since we cannot read plaintext from DB after the fact, the download will prompt. At creation time, the dashboard shows the password once for the user to copy.

Remove these lines:
```go
// Embed credentials inline so the user isn't prompted
ovpn.WriteString("<auth-user-pass>\n")
ovpn.WriteString(conn.Username + "\n")
ovpn.WriteString(conn.PasswordPlain + "\n")
ovpn.WriteString("</auth-user-pass>\n")
ovpn.WriteString("\n")
```

**connection_service.go — stop exposing PasswordPlain in API responses:**
In `GetByID()` (line 142), `ListByDevice()` (line 152), and `List()` (line 163), remove the lines that copy PasswordPlain to Password:
```go
// REMOVE: conn.Password = conn.PasswordPlain
```
After this change, the `password` JSON field will only be populated on the creation response (where it's set explicitly to `req.Password` in Create()). Existing connections will return `password: ""` (omitempty means it won't appear in JSON).

**IMPORTANT — Do NOT change these paths (SOCKS5 tunnel still needs plaintext internally):**
- `connection_service.go Create()` line 89: `PasswordPlain: req.Password` — KEEP
- `connection_repo.go Create()` line 20-23: INSERT with password_plain — KEEP
- `openvpn_handler.go Connect()` line 112: `"socks_pass": conn.PasswordPlain` — KEEP
- `device_handler.go Heartbeat()` lines 163-166: credentials via heartbeat — KEEP
- `sync_service.go`: PasswordPlain sync — KEEP
  </action>
  <verify>
    <automated>cd server && go build ./... 2>&1 | head -20</automated>
  </verify>
  <done>
    - OpenVPN Auth() uses bcrypt.CompareHashAndPassword instead of plaintext comparison
    - .ovpn download no longer embeds plaintext credentials inline
    - API responses for GetByID/List/ListByDevice do not expose password field
    - SOCKS5 paths (Connect socks_pass, heartbeat credentials) still use PasswordPlain internally
    - Migration file adds webhook_url and last_offline_alert_at columns
  </done>
</task>

<task type="auto">
  <name>Task 2: Regenerate password endpoint and dashboard button</name>
  <files>
    server/internal/repository/connection_repo.go
    server/internal/service/connection_service.go
    server/internal/api/handler/connection_handler.go
    server/internal/api/handler/router.go
    dashboard/src/lib/api.ts
    dashboard/src/components/connections/ConnectionTable.tsx
  </files>
  <action>
**connection_repo.go — add UpdatePasswordHash method:**
```go
func (r *ConnectionRepository) UpdatePasswordHash(ctx context.Context, id uuid.UUID, hash string, plain string) error {
    query := `UPDATE proxy_connections SET password_hash = $2, password_plain = $3, updated_at = NOW() WHERE id = $1`
    _, err := r.db.Pool.Exec(ctx, query, id, hash, plain)
    return err
}
```
Note: We update both hash AND plain because the SOCKS5 tunnel path needs the plaintext. The bcrypt hash is used for OpenVPN auth. This is the pragmatic resolution of Open Question #1.

**connection_service.go — add RegeneratePassword method:**
```go
func (s *ConnectionService) RegeneratePassword(ctx context.Context, id uuid.UUID) (string, error) {
    // Generate 16-character random password
    b := make([]byte, 12)
    if _, err := rand.Read(b); err != nil {
        return "", fmt.Errorf("generate password: %w", err)
    }
    newPass := base64.URLEncoding.EncodeToString(b)[:16]

    hash, err := bcrypt.GenerateFromPassword([]byte(newPass), 12)
    if err != nil {
        return "", fmt.Errorf("hash password: %w", err)
    }

    if err := s.connRepo.UpdatePasswordHash(ctx, id, string(hash), newPass); err != nil {
        return "", fmt.Errorf("update password: %w", err)
    }

    // Sync credentials to device via heartbeat (device will get new creds on next heartbeat)
    conn, err := s.connRepo.GetByID(ctx, id)
    if err == nil && s.syncService != nil {
        conns, err := s.connRepo.ListByDevice(ctx, conn.DeviceID)
        if err == nil {
            go s.syncService.SyncConnections(conn.DeviceID, conns)
        }
    }

    return newPass, nil
}
```
Add imports: `"crypto/rand"`, `"encoding/base64"`, `"golang.org/x/crypto/bcrypt"` (bcrypt already imported).

**connection_handler.go — add RegeneratePassword handler:**
```go
func (h *ConnectionHandler) RegeneratePassword(c *gin.Context) {
    id, err := uuid.Parse(c.Param("id"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid connection id"})
        return
    }

    newPass, err := h.connService.RegeneratePassword(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"password": newPass})
}
```

**router.go — wire the new endpoint:**
After `dashboard.DELETE("/connections/:id", connHandler.Delete)` add:
```go
dashboard.POST("/connections/:id/regenerate-password", connHandler.RegeneratePassword)
```

**dashboard/src/lib/api.ts — add regeneratePassword function:**
In the `connections` object, add after `delete`:
```typescript
regeneratePassword: (token: string, id: string) =>
    request<{ password: string }>(`/connections/${id}/regenerate-password`, { method: 'POST', token }),
```

**dashboard/src/components/connections/ConnectionTable.tsx — add Regenerate button:**
Add a "Regenerate" button (small, variant="ghost") on each connection row, next to the existing action buttons. When clicked:
1. Call `api.connections.regeneratePassword(token, connection.id)`
2. Show the new password in a small dialog/alert with a copy button
3. Display a note: "Save this password now. It will not be shown again."
4. Use a local state variable (e.g., `regeneratedPassword`) to hold the one-time password
5. Clear the state when the dialog is closed

Use the existing `Copy` icon from lucide-react. Use a simple AlertDialog from shadcn/ui (already installed) for the password display.

Import `RefreshCw` from lucide-react for the button icon. Follow the existing pattern of inline state management (copiedKey with 2s timeout) used for copy buttons in this component.
  </action>
  <verify>
    <automated>cd server && go build ./... 2>&1 | head -20</automated>
  </verify>
  <done>
    - POST /api/connections/:id/regenerate-password returns new plaintext password once
    - Password hash updated in DB with bcrypt cost 12
    - PasswordPlain also updated so SOCKS5 tunnel path continues working
    - Dashboard shows "Regenerate" button on each connection row
    - Clicking Regenerate shows new password in dialog with copy button and "will not be shown again" warning
    - Sync service notified so device gets new credentials on next heartbeat
  </done>
</task>

</tasks>

<verification>
1. `cd server && go build ./...` compiles without errors
2. Auth() in openvpn_handler.go uses `bcrypt.CompareHashAndPassword` (grep confirms)
3. DownloadOVPN no longer contains `auth-user-pass` inline block (grep confirms no `<auth-user-pass>` in the function)
4. Connection API responses do not include `password` field for existing connections (GetByID, List)
5. RegeneratePassword endpoint exists in router.go
6. Dashboard ConnectionTable has a Regenerate button
7. Migration file creates webhook_url and last_offline_alert_at columns
</verification>

<success_criteria>
- OpenVPN authentication uses bcrypt hash comparison, not plaintext string comparison
- Operator can regenerate a password from the dashboard and sees the new password exactly once
- All existing SOCKS5/tunnel paths continue to function (PasswordPlain stays populated)
- Go server compiles cleanly
- Migration file is ready for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-and-monitoring/03-01-SUMMARY.md`
</output>
