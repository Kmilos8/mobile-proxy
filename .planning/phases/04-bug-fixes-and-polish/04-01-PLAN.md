---
phase: 04-bug-fixes-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/cmd/api/main.go
  - server/cmd/tunnel/main.go
  - server/internal/service/connection_service.go
  - dashboard/src/components/connections/AddConnectionModal.tsx
autonomous: true
requirements: [MON-01, MON-02, DASH-02]

must_haves:
  truths:
    - "When a device reconnects after being offline, a recovery webhook POST is delivered to the operator's configured URL"
    - "Clicking Reset Usage in the dashboard resets both the DB value and the tunnel's in-memory counter — usage does not reappear after the next 30s flush"
    - "Creating an OpenVPN config from the Add Connection modal succeeds without 'must be http or socks5' error"
  artifacts:
    - path: "server/cmd/api/main.go"
      provides: "deviceService.SetUserRepo(userRepo) wiring for recovery webhooks"
      contains: "deviceService.SetUserRepo"
    - path: "server/cmd/tunnel/main.go"
      provides: "handleResetBandwidth accepts username field and resolves via reverse lookup"
      contains: "Username"
    - path: "server/internal/service/connection_service.go"
      provides: "ResetBandwidth calls tunnel push API after DB reset"
      contains: "resetTunnelBandwidth"
    - path: "dashboard/src/components/connections/AddConnectionModal.tsx"
      provides: "OpenVPN option in protocol selector"
      contains: "openvpn"
  key_links:
    - from: "server/cmd/api/main.go"
      to: "server/internal/service/device_service.go"
      via: "SetUserRepo setter injection"
      pattern: "deviceService\\.SetUserRepo\\(userRepo\\)"
    - from: "server/internal/service/connection_service.go"
      to: "server/cmd/tunnel/main.go"
      via: "HTTP POST to tunnel /openvpn-client-reset-bandwidth"
      pattern: "resetTunnelBandwidth"
    - from: "dashboard/src/components/connections/AddConnectionModal.tsx"
      to: "server/internal/api/handler/connection_handler.go"
      via: "POST /api/connections with proxy_type=openvpn"
      pattern: "openvpn"
---

<objective>
Fix three audit gaps: wire recovery webhook in API process, propagate bandwidth reset to tunnel in-memory counter, and add OpenVPN to the Add Connection modal protocol selector.

Purpose: Close MON-01 (recovery webhook silent drop), MON-02 (reset usage not propagated to tunnel), and DASH-02 (OpenVPN creation bug) identified in v1.0 milestone audit.
Output: Three backend fixes + one frontend fix deployed. Recovery webhooks fire on reconnect, bandwidth resets survive the 30s flush, and OpenVPN connections can be created from the dashboard.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-bug-fixes-and-polish/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From server/cmd/api/main.go (line 26, 42-44):
```go
userRepo := repository.NewUserRepository(db)
// ...
deviceService := service.NewDeviceService(deviceRepo, ipHistRepo, commandRepo, portService, vpnService)
deviceService.SetStatusLogRepo(statusLogRepo)
// MISSING: deviceService.SetUserRepo(userRepo) — this is the MON-01 gap
deviceService.SetRelayServerRepo(relayServerRepo)
```

From server/internal/service/device_service.go (line 57):
```go
func (s *DeviceService) SetUserRepo(repo *repository.UserRepository) {
    s.userRepo = repo
}
```

From server/internal/service/connection_service.go (lines 249-251):
```go
func (s *ConnectionService) ResetBandwidth(ctx context.Context, id uuid.UUID) error {
    return s.connRepo.ResetBandwidthUsed(ctx, id)
}
```

From server/internal/service/connection_service.go (line 54):
```go
func (s *ConnectionService) getTunnelPushURL(ctx context.Context, device *domain.Device) string
```

From server/cmd/tunnel/main.go (lines 1156-1174):
```go
func (s *tunnelServer) handleResetBandwidth(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
        return
    }
    var req struct {
        ClientVPNIP string `json:"client_vpn_ip"`
    }
    json.NewDecoder(r.Body).Decode(&req)
    s.routingMu.Lock()
    if ctr, ok := s.clientBandwidthUsed[req.ClientVPNIP]; ok {
        ctr.Store(0)
    }
    s.routingMu.Unlock()
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{"ok":true}`))
}
```

From server/cmd/tunnel/main.go (lines 88-96 — clientSocksAuth map structure):
```go
type socksAuth struct {
    user string
    pass string
}
// s.clientSocksAuth is map[string]socksAuth where key = VPN IP (e.g., "10.9.0.2")
```

From dashboard/src/components/connections/AddConnectionModal.tsx (line 37):
```typescript
const [proxyType, setProxyType] = useState<'http' | 'socks5'>('http')
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire recovery webhook and extend tunnel bandwidth reset</name>
  <files>server/cmd/api/main.go, server/cmd/tunnel/main.go</files>
  <action>
**MON-01 fix — server/cmd/api/main.go:**
Add `deviceService.SetUserRepo(userRepo)` on the line immediately after `deviceService.SetStatusLogRepo(statusLogRepo)` (line 43). The `userRepo` variable is already instantiated at line 26. This single line wires the user repository so the device service can look up the operator's webhook URL during the offline-to-online heartbeat transition, enabling recovery webhook delivery.

Do NOT modify any logic in device_service.go — the recovery webhook code is already correct, it just lacks the userRepo dependency in the API process.

**MON-02 fix (tunnel side) — server/cmd/tunnel/main.go:**
Replace the `handleResetBandwidth` method (lines 1156-1174) to accept both `client_vpn_ip` (existing) and `username` (new) fields in the JSON body. When `client_vpn_ip` is empty but `username` is provided, perform a reverse lookup by iterating `s.clientSocksAuth` map to find the VPN IP whose `.user` field matches the provided username. Then reset the bandwidth counter as before.

Exact replacement for handleResetBandwidth:
```go
func (s *tunnelServer) handleResetBandwidth(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
        return
    }
    var req struct {
        ClientVPNIP string `json:"client_vpn_ip"`
        Username    string `json:"username"`
    }
    json.NewDecoder(r.Body).Decode(&req)

    s.routingMu.Lock()
    targetIP := req.ClientVPNIP
    if targetIP == "" && req.Username != "" {
        for ip, auth := range s.clientSocksAuth {
            if auth.user == req.Username {
                targetIP = ip
                break
            }
        }
    }
    if targetIP != "" {
        if ctr, ok := s.clientBandwidthUsed[targetIP]; ok {
            ctr.Store(0)
        }
    }
    s.routingMu.Unlock()

    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{"ok":true}`))
}
```

IMPORTANT: Use a single `routingMu.Lock()` / `routingMu.Unlock()` pair — do NOT nest a second lock. The existing lock already protects both `clientSocksAuth` and `clientBandwidthUsed`.
  </action>
  <verify>
    <automated>cd server && go build ./cmd/api/ && go build ./cmd/tunnel/ && echo "BUILD OK"</automated>
  </verify>
  <done>api/main.go has SetUserRepo call. tunnel handleResetBandwidth accepts username field with reverse lookup. Both binaries compile.</done>
</task>

<task type="auto">
  <name>Task 2: Propagate bandwidth reset from service to tunnel</name>
  <files>server/internal/service/connection_service.go</files>
  <action>
**MON-02 fix (service side) — server/internal/service/connection_service.go:**

Replace the `ResetBandwidth` method (lines 249-251) to also call the tunnel push API after the DB reset:

```go
func (s *ConnectionService) ResetBandwidth(ctx context.Context, id uuid.UUID) error {
    if err := s.connRepo.ResetBandwidthUsed(ctx, id); err != nil {
        return err
    }
    // Best-effort: reset tunnel in-memory counter to prevent 30s flush overwriting the zero
    conn, err := s.connRepo.GetByID(ctx, id)
    if err != nil {
        return nil // DB reset succeeded; tunnel reset is best-effort
    }
    device, err := s.deviceRepo.GetByID(ctx, conn.DeviceID)
    if err != nil {
        return nil
    }
    tunnelURL := s.getTunnelPushURL(ctx, device)
    if tunnelURL != "" {
        go s.resetTunnelBandwidth(tunnelURL, conn.Username)
    }
    return nil
}
```

Add a new private method `resetTunnelBandwidth` below `ResetBandwidth`:

```go
func (s *ConnectionService) resetTunnelBandwidth(tunnelURL, username string) {
    body, _ := json.Marshal(map[string]string{"username": username})
    client := &http.Client{Timeout: 3 * time.Second}
    resp, err := client.Post(tunnelURL+"/openvpn-client-reset-bandwidth", "application/json", strings.NewReader(string(body)))
    if err != nil {
        log.Printf("[reset-bandwidth] tunnel call failed for %s: %v", username, err)
        return
    }
    resp.Body.Close()
}
```

IMPORTANT: The tunnel call is fire-and-forget (goroutine). Return nil from ResetBandwidth even if the tunnel call would fail — the DB reset is the source of truth. The tunnel counter becomes consistent at the next client connect.

Ensure the necessary imports are present at the top of the file: `net/http`, `strings`, `encoding/json`, `time`, `log`. Most should already be imported — only add what's missing.
  </action>
  <verify>
    <automated>cd server && go build ./... && echo "BUILD OK"</automated>
  </verify>
  <done>ResetBandwidth calls tunnel push API with username. resetTunnelBandwidth is fire-and-forget. Server compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: Add OpenVPN option to Add Connection modal</name>
  <files>dashboard/src/components/connections/AddConnectionModal.tsx</files>
  <action>
**DASH-02 fix — AddConnectionModal.tsx:**

Three changes in AddConnectionModal.tsx:

1. **Line 37** — Widen the useState type to include 'openvpn':
   Change: `useState<'http' | 'socks5'>('http')`
   To: `useState<'http' | 'socks5' | 'openvpn'>('http')`

2. **Line 105** — Widen the onValueChange cast:
   Change: `val as 'http' | 'socks5'`
   To: `val as 'http' | 'socks5' | 'openvpn'`

3. **After line 112** (after the SOCKS5 SelectItem) — Add the OpenVPN SelectItem:
   Add: `<SelectItem value="openvpn" className="text-white focus:bg-zinc-700">OpenVPN</SelectItem>`

The form reset on close (line 48: `setProxyType('http')`) and the form reset after creation (line 81: `setProxyType('http')`) remain unchanged — defaulting to HTTP on close/create is correct behavior.

No backend changes needed — `connection_service.Create` already handles "openvpn" as a valid proxy_type.
  </action>
  <verify>
    <automated>cd dashboard && npx tsc --noEmit 2>&1 | head -20 && echo "TSC OK"</automated>
  </verify>
  <done>AddConnectionModal protocol selector includes HTTP, SOCKS5, and OpenVPN. TypeScript compiles without errors. OpenVPN connections can be created from the modal.</done>
</task>

</tasks>

<verification>
1. `cd server && go build ./...` — all Go packages compile
2. `cd dashboard && npx tsc --noEmit` — TypeScript compiles without errors
3. Code review: `server/cmd/api/main.go` contains `deviceService.SetUserRepo(userRepo)` after `SetStatusLogRepo`
4. Code review: `server/cmd/tunnel/main.go` `handleResetBandwidth` accepts both `client_vpn_ip` and `username` fields
5. Code review: `server/internal/service/connection_service.go` `ResetBandwidth` calls `resetTunnelBandwidth` via goroutine
6. Code review: `AddConnectionModal.tsx` has three SelectItems (http, socks5, openvpn) and widened type union
</verification>

<success_criteria>
- Recovery webhook wiring: `deviceService.SetUserRepo(userRepo)` present in api/main.go
- Bandwidth reset propagation: ResetBandwidth → tunnel HTTP POST with username, tunnel resolves username → VPN IP
- OpenVPN in modal: Three-option protocol selector with 'openvpn' type union
- All builds pass: Go and TypeScript compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-bug-fixes-and-polish/04-01-SUMMARY.md`
</output>
