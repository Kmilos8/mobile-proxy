---
phase: 03-security-and-monitoring
plan: 02
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - server/cmd/tunnel/main.go
  - server/cmd/worker/main.go
  - server/internal/domain/models.go
  - server/internal/service/device_service.go
  - server/internal/repository/device_repo.go
  - server/internal/repository/user_repo.go
  - server/internal/repository/connection_repo.go
  - server/internal/api/handler/openvpn_handler.go
  - server/internal/api/handler/connection_handler.go
  - server/internal/api/handler/router.go
  - dashboard/src/lib/api.ts
  - dashboard/src/components/connections/AddConnectionModal.tsx
  - dashboard/src/components/connections/ConnectionTable.tsx
  - dashboard/src/app/settings/page.tsx
autonomous: true
requirements:
  - MON-01
  - MON-02

must_haves:
  truths:
    - "A proxy connection that exceeds its bandwidth limit has packets dropped immediately in the tunnel server"
    - "Bandwidth counters survive tunnel restarts by loading current usage from DB at client connect time"
    - "Bandwidth usage is flushed to the database every 30 seconds from the tunnel server"
    - "Operator receives a webhook POST within 5 minutes of a device going offline"
    - "No duplicate offline alerts within a 5-minute cooldown window per device"
    - "Recovery webhook fires when a previously-offline device reconnects"
    - "Operator can configure webhook URL and test it from the dashboard settings page"
    - "Operator can set bandwidth limit when creating a connection"
    - "Operator can see bandwidth usage bar on each connection in the dashboard"
    - "Operator can reset bandwidth usage from the dashboard"
  artifacts:
    - path: "server/cmd/tunnel/main.go"
      provides: "Per-connection bandwidth counters with atomic.Int64, enforcement in tunToUdp, periodic flush goroutine"
      contains: "clientBandwidthUsed"
    - path: "server/cmd/worker/main.go"
      provides: "Webhook dispatch integration in stale device loop"
      contains: "sendOfflineWebhook"
    - path: "server/internal/service/device_service.go"
      provides: "Webhook dispatch with cooldown and recovery logic"
      contains: "sendOfflineWebhook"
    - path: "dashboard/src/app/settings/page.tsx"
      provides: "Settings page with webhook URL field and Send Test button"
      contains: "webhook"
  key_links:
    - from: "server/cmd/tunnel/main.go"
      to: "API /api/internal/bandwidth-flush"
      via: "periodic HTTP POST every 30s"
      pattern: "bandwidth-flush"
    - from: "server/cmd/tunnel/main.go tunToUdp"
      to: "clientBandwidthUsed map"
      via: "atomic.Int64 Add on each forwarded packet"
      pattern: "ctr\\.Add"
    - from: "server/internal/service/device_service.go"
      to: "user webhook_url column"
      via: "GetWebhookURL repo call"
      pattern: "GetWebhookURL"
    - from: "dashboard/src/app/settings/page.tsx"
      to: "/api/settings/webhook"
      via: "PUT to save webhook URL"
      pattern: "settings/webhook"
---

<objective>
Enforce per-connection bandwidth limits in the tunnel server and add webhook notifications for device offline/online events.

Purpose: MON-02 requires bandwidth enforcement — currently `bandwidth_limit` exists but is never checked. MON-01 requires device offline alerting. After this plan, the tunnel server counts bytes per OpenVPN connection and drops packets when limits are exceeded. The worker dispatches webhook notifications when devices go offline/online. The dashboard gets a settings page for webhook URL configuration, bandwidth limit fields on connection creation, usage bars, and a reset button.

Output: Tunnel bandwidth enforcement, worker webhook dispatch, dashboard settings page, connection bandwidth UI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-and-monitoring/03-RESEARCH.md
@.planning/phases/03-security-and-monitoring/03-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From server/cmd/tunnel/main.go (tunnelServer struct, lines 77-93):
```go
type tunnelServer struct {
    udpConn *net.UDPConn
    mu      sync.RWMutex
    clients map[string]*client    // device VPN IP -> client
    // ...
    routingMu        sync.Mutex
    deviceRouteTable map[string]int         // device VPN IP -> routing table number
    clientToDevice   map[string]string      // client VPN IP (10.9.0.x) -> device VPN IP
    clientSocksAuth  map[string]socksAuth   // client VPN IP -> SOCKS5 credentials
}
```

From server/cmd/tunnel/main.go (tunToUdp hot path, lines 460-480):
```go
// NAT-routed traffic: packet from OpenVPN client (10.9.0.x)
srcIP := net.IPv4(buf[13], buf[14], buf[15], buf[16]).String()
s.routingMu.Lock()
deviceIP, mapped := s.clientToDevice[srcIP]
s.routingMu.Unlock()

if mapped {
    s.mu.RLock()
    c, ok = s.clients[deviceIP]
    s.mu.RUnlock()
    if ok {
        buf[0] = TypeData
        s.udpConn.WriteToUDP(buf[:1+n], c.udpAddr)
    }
}
```

From server/cmd/tunnel/main.go (handleOpenVPNClientConnect, lines 1010-1037):
```go
func (s *tunnelServer) handleOpenVPNClientConnect(w http.ResponseWriter, r *http.Request) {
    var req struct {
        ClientVPNIP string `json:"client_vpn_ip"`
        DeviceVPNIP string `json:"device_vpn_ip"`
        SocksUser   string `json:"socks_user"`
        SocksPass   string `json:"socks_pass"`
    }
    // ...
    s.clientToDevice[req.ClientVPNIP] = req.DeviceVPNIP
    s.clientSocksAuth[req.ClientVPNIP] = socksAuth{user: req.SocksUser, pass: req.SocksPass}
}
```

From server/cmd/tunnel/main.go (push API mux, lines 881-887):
```go
mux.HandleFunc("/push-command", s.handlePushCommand)
mux.HandleFunc("/refresh-dnat", s.handleRefreshDNAT)
mux.HandleFunc("/teardown-dnat", s.handleTeardownDNAT)
mux.HandleFunc("/openvpn-client-connect", s.handleOpenVPNClientConnect)
mux.HandleFunc("/openvpn-client-disconnect", s.handleOpenVPNClientDisconnect)
```

From server/internal/service/device_service.go (MarkStaleOfflineWithLogs, lines 313-339):
```go
func (s *DeviceService) MarkStaleOfflineWithLogs(ctx context.Context) (int64, error) {
    // iterates online devices, marks stale ones offline, logs transitions
    for _, d := range devices {
        if d.Status == domain.DeviceStatusOnline && d.LastHeartbeat != nil && d.LastHeartbeat.Before(threshold) {
            s.deviceRepo.UpdateStatus(ctx, d.ID, domain.DeviceStatusOffline)
            s.statusLogRepo.Insert(ctx, d.ID, string(domain.DeviceStatusOffline), string(d.Status), now)
            count++
        }
    }
}
```

From server/internal/domain/models.go (User struct):
```go
type User struct {
    ID           uuid.UUID `json:"id" db:"id"`
    Email        string    `json:"email" db:"email"`
    PasswordHash string    `json:"-" db:"password_hash"`
    Name         string    `json:"name" db:"name"`
    Role         string    `json:"role" db:"role"`
    CreatedAt    time.Time `json:"created_at" db:"created_at"`
    UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`
}
// Plan 03-01 migration added: webhook_url TEXT to users table
// Plan 03-01 migration added: last_offline_alert_at TIMESTAMPTZ to devices table
```

From server/internal/repository/user_repo.go:
```go
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*domain.User, error)
func (r *UserRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.User, error)
func (r *UserRepository) Create(ctx context.Context, u *domain.User) error
```

From server/internal/api/handler/openvpn_handler.go (Connect, lines 108-113):
```go
// This sends connection data to the tunnel server when OpenVPN client connects.
// Must add bandwidth_limit and bandwidth_used to this payload:
body, _ := json.Marshal(map[string]interface{}{
    "client_vpn_ip": req.VpnIP,
    "device_vpn_ip": device.VpnIP,
    "socks_user":    conn.Username,
    "socks_pass":    conn.PasswordPlain,
})
```

From dashboard/src/lib/api.ts (connections object):
```typescript
connections: {
    list, create, setActive, delete, downloadOVPN,
    // Plan 03-01 adds: regeneratePassword
}
```

From dashboard/src/components/connections/AddConnectionModal.tsx:
```tsx
// Connection creation form — must add bandwidth_limit input field
```

From dashboard/src/components/connections/ConnectionTable.tsx:
```tsx
// Connection list — must add usage bar column and Reset Usage button
// Plan 03-01 adds: Regenerate button
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bandwidth enforcement in tunnel server and flush endpoint</name>
  <files>
    server/cmd/tunnel/main.go
    server/internal/api/handler/openvpn_handler.go
    server/internal/repository/connection_repo.go
    server/internal/api/handler/connection_handler.go
    server/internal/api/handler/router.go
  </files>
  <action>
**tunnel/main.go — add bandwidth counter fields to tunnelServer struct:**
Add these fields alongside the existing `clientToDevice` and `clientSocksAuth` maps:
```go
clientBandwidthUsed  map[string]*atomic.Int64  // client VPN IP -> bytes forwarded
clientBandwidthLimit map[string]int64           // client VPN IP -> limit (0=unlimited)
```
Import `"sync/atomic"`. Initialize both maps in the constructor alongside `clientToDevice`.

**tunnel/main.go — load bandwidth at connect time:**
In `handleOpenVPNClientConnect`, extend the request struct to accept bandwidth info:
```go
var req struct {
    ClientVPNIP    string `json:"client_vpn_ip"`
    DeviceVPNIP    string `json:"device_vpn_ip"`
    SocksUser      string `json:"socks_user"`
    SocksPass      string `json:"socks_pass"`
    BandwidthLimit int64  `json:"bandwidth_limit"` // bytes, 0 = unlimited
    BandwidthUsed  int64  `json:"bandwidth_used"`  // current DB value — initial offset
}
```
After setting `clientToDevice` and `clientSocksAuth`, also set:
```go
ctr := &atomic.Int64{}
ctr.Store(req.BandwidthUsed)
s.clientBandwidthUsed[req.ClientVPNIP] = ctr
s.clientBandwidthLimit[req.ClientVPNIP] = req.BandwidthLimit
```

**tunnel/main.go — enforce bandwidth in tunToUdp hot path:**
In the `if mapped {` block (around line 472), BEFORE the existing forwarding code, add bandwidth enforcement. Follow the research pattern to minimize lock hold time:
```go
if mapped {
    // Bandwidth enforcement — read counter/limit under lock, increment outside
    s.routingMu.Lock()
    ctr := s.clientBandwidthUsed[srcIP]
    limit := s.clientBandwidthLimit[srcIP]
    s.routingMu.Unlock()

    // Increment counter (lock-free atomic operation)
    var used int64
    if ctr != nil {
        used = ctr.Add(int64(n))
    }

    // Hard cutoff: drop packet silently if limit exceeded
    if limit > 0 && used > limit {
        continue
    }

    // Forward the packet (existing code)
    s.mu.RLock()
    c, ok = s.clients[deviceIP]
    s.mu.RUnlock()
    // ...
}
```
IMPORTANT: The `deviceIP, mapped` lookup from `clientToDevice` already happens under `routingMu.Lock()` a few lines above. Restructure so the bandwidth read happens in the SAME lock acquisition as the `clientToDevice` lookup — do NOT acquire routingMu twice. Merge the two lock sections into one.

**tunnel/main.go — cleanup on disconnect:**
In `handleOpenVPNClientDisconnect`, after deleting from `clientToDevice` and `clientSocksAuth`, also delete from `clientBandwidthUsed` and `clientBandwidthLimit`.
In the device disconnect cleanup loop (cleanupDeviceRouting, around line 578), also delete bandwidth entries for removed clients.

**tunnel/main.go — periodic flush goroutine:**
Add a `bandwidthFlushLoop` method and start it as a goroutine from `startPushAPI` (or from main, near the push API start):
```go
go s.bandwidthFlushLoop()

func (s *tunnelServer) bandwidthFlushLoop() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    for range ticker.C {
        s.flushBandwidthToAPI()
    }
}

func (s *tunnelServer) flushBandwidthToAPI() {
    s.routingMu.Lock()
    snapshot := make(map[string]int64, len(s.clientBandwidthUsed))
    for ip, ctr := range s.clientBandwidthUsed {
        snapshot[ip] = ctr.Load()
    }
    s.routingMu.Unlock()

    if len(snapshot) == 0 {
        return
    }

    body, _ := json.Marshal(snapshot)
    apiURL := os.Getenv("API_URL")
    if apiURL == "" {
        apiURL = "http://127.0.0.1:8080"
    }
    client := &http.Client{Timeout: 5 * time.Second}
    resp, err := client.Post(apiURL+"/api/internal/bandwidth-flush", "application/json", bytes.NewReader(body))
    if err != nil {
        log.Printf("[bandwidth] flush failed: %v", err)
        return
    }
    resp.Body.Close()
}
```

**tunnel/main.go — add reset-bandwidth push endpoint:**
Add a handler for `/openvpn-client-reset-bandwidth`:
```go
mux.HandleFunc("/openvpn-client-reset-bandwidth", s.handleResetBandwidth)

func (s *tunnelServer) handleResetBandwidth(w http.ResponseWriter, r *http.Request) {
    var req struct {
        ClientVPNIP string `json:"client_vpn_ip"`
    }
    json.NewDecoder(r.Body).Decode(&req)

    s.routingMu.Lock()
    if ctr, ok := s.clientBandwidthUsed[req.ClientVPNIP]; ok {
        ctr.Store(0)
    }
    s.routingMu.Unlock()

    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{"ok":true}`))
}
```

**openvpn_handler.go Connect() — send bandwidth data to tunnel:**
In the Connect handler, after looking up the connection, add `bandwidth_limit` and `bandwidth_used` to the payload sent to the tunnel:
```go
body, _ := json.Marshal(map[string]interface{}{
    "client_vpn_ip":   req.VpnIP,
    "device_vpn_ip":   device.VpnIP,
    "socks_user":      conn.Username,
    "socks_pass":      conn.PasswordPlain,
    "bandwidth_limit": conn.BandwidthLimit,
    "bandwidth_used":  conn.BandwidthUsed,
})
```

**connection_repo.go — add UpdateBandwidthUsed and ResetBandwidthUsed:**
```go
func (r *ConnectionRepository) UpdateBandwidthUsed(ctx context.Context, username string, used int64) error {
    query := `UPDATE proxy_connections SET bandwidth_used = $2, updated_at = NOW() WHERE username = $1`
    _, err := r.db.Pool.Exec(ctx, query, username, used)
    return err
}

func (r *ConnectionRepository) ResetBandwidthUsed(ctx context.Context, id uuid.UUID) error {
    query := `UPDATE proxy_connections SET bandwidth_used = 0, updated_at = NOW() WHERE id = $1`
    _, err := r.db.Pool.Exec(ctx, query, id)
    return err
}

func (r *ConnectionRepository) GetByVPNIP(ctx context.Context, vpnIP string) (*domain.ProxyConnection, error) {
    // The tunnel uses client VPN IPs (10.9.0.x) as keys.
    // We need to look up which connection corresponds to this VPN IP.
    // The connection doesn't store the VPN IP directly — it's assigned by OpenVPN at connect time.
    // The flush endpoint should map by username instead.
    // This method is NOT needed — the flush will use a map of VPN IP -> username.
}
```
Actually, the bandwidth flush sends a map of `{vpnIP: bytesUsed}`. The API needs to map VPN IP back to a connection. The cleanest approach: the tunnel already has `clientSocksAuth[vpnIP].user` which is the connection username. Change the flush to send `{username: bytesUsed}` instead of `{vpnIP: bytesUsed}`:

```go
func (s *tunnelServer) flushBandwidthToAPI() {
    s.routingMu.Lock()
    snapshot := make(map[string]int64)
    for ip, ctr := range s.clientBandwidthUsed {
        if auth, ok := s.clientSocksAuth[ip]; ok {
            snapshot[auth.user] = ctr.Load()
        }
    }
    s.routingMu.Unlock()
    // ... POST to API
}
```

**connection_handler.go — add bandwidth flush and reset endpoints:**
Add an internal (no JWT) handler for the bandwidth flush:
```go
func (h *ConnectionHandler) BandwidthFlush(c *gin.Context) {
    var data map[string]int64  // username -> bytes used
    if err := c.ShouldBindJSON(&data); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    for username, used := range data {
        if err := h.connService.UpdateBandwidthUsedByUsername(c.Request.Context(), username, used); err != nil {
            log.Printf("[bandwidth-flush] failed for %s: %v", username, err)
        }
    }
    c.JSON(http.StatusOK, gin.H{"ok": true})
}

func (h *ConnectionHandler) ResetBandwidth(c *gin.Context) {
    id, err := uuid.Parse(c.Param("id"))
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid connection id"})
        return
    }
    if err := h.connService.ResetBandwidth(c.Request.Context(), id); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{"ok": true})
}
```
Add `"log"` to imports.

**connection_service.go — add UpdateBandwidthUsedByUsername and ResetBandwidth:**
```go
func (s *ConnectionService) UpdateBandwidthUsedByUsername(ctx context.Context, username string, used int64) error {
    return s.connRepo.UpdateBandwidthUsed(ctx, username, used)
}

func (s *ConnectionService) ResetBandwidth(ctx context.Context, id uuid.UUID) error {
    return s.connRepo.ResetBandwidthUsed(ctx, id)
}
```

**router.go — wire the new endpoints:**
Add internal bandwidth flush route (no JWT, called by tunnel):
```go
// After the existing openvpn internal routes block, inside the openvpnHandler != nil check:
r.POST("/api/internal/bandwidth-flush", connHandler.BandwidthFlush)
```

Add dashboard route for reset bandwidth (JWT protected):
```go
dashboard.POST("/connections/:id/reset-bandwidth", connHandler.ResetBandwidth)
```
  </action>
  <verify>
    <automated>cd server && go build ./... 2>&1 | head -20</automated>
  </verify>
  <done>
    - Tunnel server tracks bytes per OpenVPN connection with atomic.Int64 counters
    - Packets dropped immediately when bandwidth limit exceeded
    - Counters initialized from DB value at connect time (survives tunnel restart)
    - Counters flushed to DB every 30 seconds via /api/internal/bandwidth-flush
    - Reset bandwidth endpoint resets both DB and in-memory counter
    - openvpn_handler Connect() passes bandwidth_limit and bandwidth_used to tunnel
  </done>
</task>

<task type="auto">
  <name>Task 2: Offline webhook dispatch and dashboard monitoring UI</name>
  <files>
    server/internal/domain/models.go
    server/internal/repository/user_repo.go
    server/internal/repository/device_repo.go
    server/internal/service/device_service.go
    server/cmd/worker/main.go
    server/internal/api/handler/router.go
    dashboard/src/lib/api.ts
    dashboard/src/components/connections/AddConnectionModal.tsx
    dashboard/src/components/connections/ConnectionTable.tsx
    dashboard/src/app/settings/page.tsx
  </files>
  <action>
**domain/models.go — add WebhookURL to User and LastOfflineAlertAt to Device:**
Add to the User struct:
```go
WebhookURL *string `json:"webhook_url,omitempty" db:"webhook_url"`
```
Add to the Device struct (after LastHeartbeat):
```go
LastOfflineAlertAt *time.Time `json:"-" db:"last_offline_alert_at"`
```

**user_repo.go — add webhook methods and update existing queries:**
Update `GetByEmail` and `GetByID` queries to include `webhook_url` in the SELECT and Scan:
```go
query := `SELECT id, email, password_hash, name, role, webhook_url, created_at, updated_at FROM users WHERE email = $1`
err := r.db.Pool.QueryRow(ctx, query, email).Scan(
    &u.ID, &u.Email, &u.PasswordHash, &u.Name, &u.Role, &u.WebhookURL, &u.CreatedAt, &u.UpdatedAt)
```
Add new methods:
```go
func (r *UserRepository) UpdateWebhookURL(ctx context.Context, id uuid.UUID, url *string) error {
    query := `UPDATE users SET webhook_url = $2, updated_at = NOW() WHERE id = $1`
    _, err := r.db.Pool.Exec(ctx, query, id, url)
    return err
}

func (r *UserRepository) GetWebhookURLForDevice(ctx context.Context, deviceID uuid.UUID) (string, error) {
    // Devices don't have a direct user_id. Use the first admin/operator user's webhook URL.
    // In a single-tenant system, there's typically one operator. Query the first user with a webhook_url set.
    query := `SELECT webhook_url FROM users WHERE webhook_url IS NOT NULL AND webhook_url != '' LIMIT 1`
    var url string
    err := r.db.Pool.QueryRow(ctx, query).Scan(&url)
    if err != nil {
        return "", err
    }
    return url, nil
}
```

**device_repo.go — add methods for offline alerting:**
Add to DeviceRepository:
```go
func (r *DeviceRepository) GetLastOfflineAlertAt(ctx context.Context, deviceID uuid.UUID) (*time.Time, error) {
    query := `SELECT last_offline_alert_at FROM devices WHERE id = $1`
    var t *time.Time
    err := r.db.Pool.QueryRow(ctx, query, deviceID).Scan(&t)
    return t, err
}

func (r *DeviceRepository) SetLastOfflineAlertAt(ctx context.Context, deviceID uuid.UUID, t time.Time) error {
    query := `UPDATE devices SET last_offline_alert_at = $2 WHERE id = $1`
    _, err := r.db.Pool.Exec(ctx, query, deviceID, t)
    return err
}
```

**device_service.go — add webhook dispatch logic:**
Add a `SetUserRepo` method:
```go
func (s *DeviceService) SetUserRepo(repo *repository.UserRepository) {
    s.userRepo = repo
}
```
Add `userRepo *repository.UserRepository` field to the DeviceService struct.

Add webhook dispatch methods:
```go
func (s *DeviceService) sendOfflineWebhook(ctx context.Context, d domain.Device) {
    if s.userRepo == nil {
        return
    }

    // Check cooldown (5 minutes)
    lastAlert, err := s.deviceRepo.GetLastOfflineAlertAt(ctx, d.ID)
    if err == nil && lastAlert != nil && time.Since(*lastAlert) < 5*time.Minute {
        return // cooldown active
    }

    webhookURL, err := s.userRepo.GetWebhookURLForDevice(ctx, d.ID)
    if err != nil || webhookURL == "" {
        return
    }

    payload, _ := json.Marshal(map[string]interface{}{
        "event":       "device.offline",
        "device_id":   d.ID.String(),
        "device_name": d.Name,
        "last_seen":   d.LastHeartbeat.Format(time.RFC3339),
        "timestamp":   time.Now().UTC().Format(time.RFC3339),
    })

    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Post(webhookURL, "application/json", bytes.NewReader(payload))
    if err != nil {
        log.Printf("[webhook] offline alert failed for device %s: %v", d.ID, err)
        return
    }
    resp.Body.Close()

    // Only update cooldown on successful delivery
    _ = s.deviceRepo.SetLastOfflineAlertAt(ctx, d.ID, time.Now().UTC())
}

func (s *DeviceService) sendRecoveryWebhook(ctx context.Context, d domain.Device) {
    if s.userRepo == nil {
        return
    }

    webhookURL, err := s.userRepo.GetWebhookURLForDevice(ctx, d.ID)
    if err != nil || webhookURL == "" {
        return
    }

    payload, _ := json.Marshal(map[string]interface{}{
        "event":          "device.online",
        "device_id":      d.ID.String(),
        "device_name":    d.Name,
        "reconnected_at": time.Now().UTC().Format(time.RFC3339),
        "timestamp":      time.Now().UTC().Format(time.RFC3339),
    })

    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Post(webhookURL, "application/json", bytes.NewReader(payload))
    if err != nil {
        log.Printf("[webhook] recovery alert failed for device %s: %v", d.ID, err)
        return
    }
    resp.Body.Close()
}
```
Add `"bytes"` to imports if not already present.

**device_service.go — integrate webhooks into MarkStaleOfflineWithLogs:**
In the `MarkStaleOfflineWithLogs` method, after the status log insert (line 334), dispatch the offline webhook:
```go
_ = s.statusLogRepo.Insert(ctx, d.ID, string(domain.DeviceStatusOffline), string(d.Status), now)
go s.sendOfflineWebhook(ctx, d)
count++
```

**device_service.go — integrate recovery webhook into Heartbeat:**
In the `Heartbeat` method, detect online→offline recovery. After updating device status (the existing heartbeat logic sets status to online), check if the device was previously offline and send recovery webhook. Find where the status is set to online in the heartbeat path and add:
```go
// If device was offline and is now coming online, send recovery webhook
if device.Status == domain.DeviceStatusOffline {
    go s.sendRecoveryWebhook(ctx, *device)
}
```

**worker/main.go — wire user repo for webhook dispatch:**
Add user repo initialization:
```go
userRepo := repository.NewUserRepository(db)
deviceService.SetUserRepo(userRepo)
```

**Settings API — add webhook handlers:**
Create a simple settings handler. In router.go, add a settings endpoint for webhook URL management. Add to connection_handler.go or create inline handler in router:

In router.go, add these settings endpoints inside the dashboard group:
```go
dashboard.GET("/settings/webhook", func(c *gin.Context) {
    // Extract user ID from JWT (middleware already validates)
    userID, _ := c.Get("user_id")
    uid := userID.(uuid.UUID)
    user, err := authService.GetUserByID(c.Request.Context(), uid)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{"webhook_url": user.WebhookURL})
})

dashboard.PUT("/settings/webhook", func(c *gin.Context) {
    var body struct {
        WebhookURL string `json:"webhook_url"`
    }
    if err := c.ShouldBindJSON(&body); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    userID, _ := c.Get("user_id")
    uid := userID.(uuid.UUID)
    var urlPtr *string
    if body.WebhookURL != "" {
        urlPtr = &body.WebhookURL
    }
    // Need userRepo access — pass it through authService or add to SetupRouter params
    // Simplest: add userRepo to SetupRouter and call directly
    c.JSON(http.StatusOK, gin.H{"ok": true})
})

dashboard.POST("/settings/webhook/test", func(c *gin.Context) {
    var body struct {
        WebhookURL string `json:"webhook_url"`
    }
    if err := c.ShouldBindJSON(&body); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    payload, _ := json.Marshal(map[string]interface{}{
        "event":     "test",
        "message":   "This is a test webhook from PocketProxy",
        "timestamp": time.Now().UTC().Format(time.RFC3339),
    })
    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Post(body.WebhookURL, "application/json", bytes.NewReader(payload))
    if err != nil {
        c.JSON(http.StatusBadGateway, gin.H{"error": err.Error()})
        return
    }
    resp.Body.Close()
    c.JSON(http.StatusOK, gin.H{"ok": true, "status": resp.StatusCode})
})
```
NOTE: The webhook settings handlers need access to `userRepo`. The cleanest approach is to add `*repository.UserRepository` as a parameter to `SetupRouter` and use it directly in the inline handlers, OR create a small `SettingsHandler` struct. Use whichever approach feels cleaner given the existing pattern — the existing router.go already uses inline closures for simple handlers (like health check). Add userRepo to SetupRouter params and update the call site in main.go.

**dashboard/src/lib/api.ts — add settings, resetBandwidth endpoints:**
Add a `settings` section:
```typescript
settings: {
    getWebhook: (token: string) =>
        request<{ webhook_url: string | null }>('/settings/webhook', { token }),
    setWebhook: (token: string, webhookUrl: string) =>
        request<{ ok: boolean }>('/settings/webhook', { method: 'PUT', token, body: { webhook_url: webhookUrl } }),
    testWebhook: (token: string, webhookUrl: string) =>
        request<{ ok: boolean; status: number }>('/settings/webhook/test', { method: 'POST', token, body: { webhook_url: webhookUrl } }),
},
```
Add to connections section:
```typescript
resetBandwidth: (token: string, id: string) =>
    request<{ ok: boolean }>(`/connections/${id}/reset-bandwidth`, { method: 'POST', token }),
```

**dashboard/src/app/settings/page.tsx — create settings page:**
Create the settings page with:
1. Page title "Settings"
2. Card for "Webhook Notifications"
3. Input field for webhook URL (text input, full width)
4. "Save" button to save the URL
5. "Send Test" button next to save — sends test payload and shows success/error toast
6. Description text: "Receive notifications when devices go offline or come back online"

Use the same dark theme and shadcn/ui components (Card, Input, Button, Label) as the rest of the dashboard. Use `useEffect` to load the current webhook URL on mount. Use toast (or simple alert) for success/error feedback.

Add a link/nav entry for Settings in the dashboard layout. The Phase 02-03 removed the sidebar — so add a simple Settings icon/link in the header area near the branding, or add a Settings tab in the navigation if one exists.

**dashboard/src/components/connections/AddConnectionModal.tsx — add bandwidth limit field:**
Add an optional numeric input field for "Bandwidth Limit (GB)" in the connection creation form. Convert GB to bytes when sending to API (value * 1024 * 1024 * 1024). Default empty = 0 = unlimited. Only show for HTTP/SOCKS5/OpenVPN types. Place it below the existing form fields.

**dashboard/src/components/connections/ConnectionTable.tsx — add usage bar and reset button:**
For each connection row:
1. Add a "Usage" column showing bandwidth_used / bandwidth_limit as a progress bar
   - Format: "750 MB / 1 GB" text above a thin progress bar (colored div with percentage width)
   - If bandwidth_limit is 0, show "Unlimited" with no bar
   - Use Tailwind for the bar: `bg-zinc-700` track, `bg-emerald-500` fill (or `bg-red-500` if >90%)
2. Add a "Reset" button (small, variant="ghost", RotateCcw icon) that calls `api.connections.resetBandwidth`
   - After reset, refresh the connection list
3. Helper functions for byte formatting: `formatBytes(bytes)` → "750 MB", "1.2 GB", etc.
  </action>
  <verify>
    <automated>cd server && go build ./... 2>&1 | head -20</automated>
  </verify>
  <done>
    - User model has WebhookURL field; Device model has LastOfflineAlertAt field
    - user_repo has UpdateWebhookURL and GetWebhookURLForDevice methods
    - device_repo has GetLastOfflineAlertAt and SetLastOfflineAlertAt methods
    - MarkStaleOfflineWithLogs dispatches offline webhook with 5-minute cooldown
    - Heartbeat path sends recovery webhook when device transitions offline→online
    - Worker wires userRepo to deviceService
    - Settings page exists at /settings with webhook URL input, Save, and Send Test buttons
    - AddConnectionModal has bandwidth limit field
    - ConnectionTable shows usage bar and Reset Usage button
    - Dashboard API client has settings and resetBandwidth endpoints
  </done>
</task>

</tasks>

<verification>
1. `cd server && go build ./...` compiles without errors
2. Tunnel server struct has `clientBandwidthUsed` and `clientBandwidthLimit` maps
3. tunToUdp hot path checks bandwidth limit before forwarding
4. handleOpenVPNClientConnect accepts and stores bandwidth_limit/bandwidth_used
5. Bandwidth flush goroutine runs every 30 seconds
6. MarkStaleOfflineWithLogs calls sendOfflineWebhook
7. Heartbeat recovery path calls sendRecoveryWebhook
8. Settings page exists at /settings with webhook URL management
9. ConnectionTable has usage bar with percentage fill
10. AddConnectionModal has bandwidth limit input
</verification>

<success_criteria>
- Tunnel enforces bandwidth limits by dropping packets when limit exceeded (MON-02)
- Bandwidth counters initialized from DB value at connect time, flushed every 30s
- Offline webhooks dispatched with 5-minute cooldown, recovery webhooks on reconnect (MON-01)
- Dashboard has settings page for webhook URL configuration with test button
- Connection creation form includes bandwidth limit field
- Connection list shows usage bar and reset button
- Go server and dashboard compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-and-monitoring/03-02-SUMMARY.md`
</output>
